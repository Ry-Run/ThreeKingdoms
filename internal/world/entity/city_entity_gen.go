// Code generated by gen_entities; DO NOT EDIT.
package entity

import (
	"sort"
	"time"
)

const (
	FieldCity_cityId     Field = "cityId"
	FieldCity_name       Field = "name"
	FieldCity_unionId    Field = "unionId"
	FieldCity_unionName  Field = "unionName"
	FieldCity_parentId   Field = "parentId"
	FieldCity_x          Field = "x"
	FieldCity_y          Field = "y"
	FieldCity_isMain     Field = "isMain"
	FieldCity_level      Field = "level"
	FieldCity_curDurable Field = "curDurable"
	FieldCity_maxDurable Field = "maxDurable"
	FieldCity_occupyTime Field = "occupyTime"
)

type CityEntityCollectionChange struct {
	FullReplace       bool
	MapSet            map[string]any
	MapDeleteKeys     []string
	SliceSet          map[int]any
	SliceAppend       []any
	SliceRemoveAt     []int
	SliceSwapRemoveAt []int
}

type CityEntityCollectionChangeInner struct {
	fullReplace       bool
	mapSet            map[string]any
	mapDelete         map[string]struct{}
	sliceSet          map[int]any
	sliceAppend       []any
	sliceRemoveAt     []int
	sliceSwapRemoveAt []int
}

type CityEntityTrace struct {
	dirty   bool
	trace   map[Field]bool
	changes map[Field]*CityEntityCollectionChangeInner
}

func (t *CityEntityTrace) mark(f Field) {
	t.dirty = true
	if t.trace == nil {
		t.trace = make(map[Field]bool, 8)
	}
	t.trace[f] = true
}

func (t *CityEntityTrace) ensureChange(f Field) *CityEntityCollectionChangeInner {
	if t.changes == nil {
		t.changes = make(map[Field]*CityEntityCollectionChangeInner, 4)
	}
	ch, ok := t.changes[f]
	if !ok || ch == nil {
		ch = &CityEntityCollectionChangeInner{}
		t.changes[f] = ch
	}
	return ch
}

func (t *CityEntityTrace) markFullReplace(f Field) {
	t.mark(f)
	ch := t.ensureChange(f)
	ch.fullReplace = true
	ch.mapSet = nil
	ch.mapDelete = nil
	ch.sliceSet = nil
	ch.sliceAppend = nil
	ch.sliceRemoveAt = nil
	ch.sliceSwapRemoveAt = nil
}

func (t *CityEntityTrace) markMapSet(f Field, key string, value any) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.mapSet == nil {
		ch.mapSet = make(map[string]any, 4)
	}
	ch.mapSet[key] = value
	if ch.mapDelete != nil {
		delete(ch.mapDelete, key)
	}
}

func (t *CityEntityTrace) markMapDelete(f Field, key string) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.mapDelete == nil {
		ch.mapDelete = make(map[string]struct{}, 4)
	}
	ch.mapDelete[key] = struct{}{}
	if ch.mapSet != nil {
		delete(ch.mapSet, key)
	}
}

func (t *CityEntityTrace) markSliceAppend(f Field, values ...any) {
	if len(values) == 0 {
		return
	}
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceAppend = append(ch.sliceAppend, values...)
}

func (t *CityEntityTrace) markSliceSet(f Field, index int, value any) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.sliceSet == nil {
		ch.sliceSet = make(map[int]any, 4)
	}
	ch.sliceSet[index] = value
}

func (t *CityEntityTrace) markSliceRemoveAt(f Field, index int) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceRemoveAt = append(ch.sliceRemoveAt, index)
}

func (t *CityEntityTrace) markSliceSwapRemoveAt(f Field, index int) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceSwapRemoveAt = append(ch.sliceSwapRemoveAt, index)
}

type CityState struct {
	CityId     CityID
	Name       string
	UnionId    int
	UnionName  string
	ParentId   int
	X          int
	Y          int
	IsMain     bool
	Level      int8
	CurDurable int
	MaxDurable int
	OccupyTime time.Time
}

type CityEntitySnap struct {
	Version     uint64
	State       CityState
	DirtyFields []Field
	Changes     map[Field]CityEntityCollectionChange
}

type CityEntity struct {
	cityId     CityID
	name       string
	unionId    int
	unionName  string
	parentId   int
	x          int
	y          int
	isMain     bool
	level      int8
	curDurable int
	maxDurable int
	occupyTime time.Time
	_dt        CityEntityTrace
}

func HydrateCityEntity(s CityState) *CityEntity {
	return &CityEntity{
		cityId:     s.CityId,
		name:       s.Name,
		unionId:    s.UnionId,
		unionName:  s.UnionName,
		parentId:   s.ParentId,
		x:          s.X,
		y:          s.Y,
		isMain:     s.IsMain,
		level:      s.Level,
		curDurable: s.CurDurable,
		maxDurable: s.MaxDurable,
		occupyTime: s.OccupyTime,
	}
}

func (e *CityEntity) Dirty() bool {
	if e == nil {
		return false
	}
	if e._dt.dirty {
		return true
	}
	return false
}

func (e *CityEntity) ClearDirty() {
	if e == nil {
		return
	}
	e._dt = CityEntityTrace{}
}

func (e *CityEntity) DirtyFields() []Field {
	if e == nil {
		return nil
	}
	trace := make(map[Field]bool, len(e._dt.trace)+4)
	for k := range e._dt.trace {
		trace[k] = true
	}
	if len(trace) == 0 {
		return nil
	}
	out := make([]Field, 0, len(trace))
	for k := range trace {
		out = append(out, k)
	}
	sort.Slice(out, func(i, j int) bool { return out[i] < out[j] })
	return out
}

func (e *CityEntity) DirtyChanges() map[Field]CityEntityCollectionChange {
	if e == nil || len(e._dt.changes) == 0 {
		return nil
	}
	out := make(map[Field]CityEntityCollectionChange, len(e._dt.changes))
	for f, ch := range e._dt.changes {
		if ch == nil {
			continue
		}
		item := CityEntityCollectionChange{
			FullReplace: ch.fullReplace,
		}
		if len(ch.mapSet) > 0 {
			item.MapSet = make(map[string]any, len(ch.mapSet))
			for k, v := range ch.mapSet {
				item.MapSet[k] = v
			}
		}
		if len(ch.mapDelete) > 0 {
			keys := make([]string, 0, len(ch.mapDelete))
			for k := range ch.mapDelete {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			item.MapDeleteKeys = keys
		}
		if len(ch.sliceSet) > 0 {
			item.SliceSet = make(map[int]any, len(ch.sliceSet))
			for idx, v := range ch.sliceSet {
				item.SliceSet[idx] = v
			}
		}
		if len(ch.sliceAppend) > 0 {
			item.SliceAppend = append([]any(nil), ch.sliceAppend...)
		}
		if len(ch.sliceRemoveAt) > 0 {
			item.SliceRemoveAt = append([]int(nil), ch.sliceRemoveAt...)
		}
		if len(ch.sliceSwapRemoveAt) > 0 {
			item.SliceSwapRemoveAt = append([]int(nil), ch.sliceSwapRemoveAt...)
		}
		out[f] = item
	}
	return out
}

func cloneCityEntityCollectionChange(in CityEntityCollectionChange) CityEntityCollectionChange {
	out := in
	if in.MapSet != nil {
		out.MapSet = make(map[string]any, len(in.MapSet))
		for k, v := range in.MapSet {
			out.MapSet[k] = v
		}
	}
	if in.MapDeleteKeys != nil {
		out.MapDeleteKeys = append([]string(nil), in.MapDeleteKeys...)
	}
	if in.SliceSet != nil {
		out.SliceSet = make(map[int]any, len(in.SliceSet))
		for idx, v := range in.SliceSet {
			out.SliceSet[idx] = v
		}
	}
	if in.SliceAppend != nil {
		out.SliceAppend = append([]any(nil), in.SliceAppend...)
	}
	if in.SliceRemoveAt != nil {
		out.SliceRemoveAt = append([]int(nil), in.SliceRemoveAt...)
	}
	if in.SliceSwapRemoveAt != nil {
		out.SliceSwapRemoveAt = append([]int(nil), in.SliceSwapRemoveAt...)
	}
	return out
}

func (e *CityEntity) Save() CityState {
	var s CityState
	if e == nil {
		return s
	}
	s.CityId = e.cityId
	s.Name = e.name
	s.UnionId = e.unionId
	s.UnionName = e.unionName
	s.ParentId = e.parentId
	s.X = e.x
	s.Y = e.y
	s.IsMain = e.isMain
	s.Level = e.level
	s.CurDurable = e.curDurable
	s.MaxDurable = e.maxDurable
	s.OccupyTime = e.occupyTime
	return s
}

func NewCityEntitySnap(version uint64, e *CityEntity) *CityEntitySnap {
	if e == nil {
		return nil
	}
	dirtyFields := e.DirtyFields()
	changes := e.DirtyChanges()
	return &CityEntitySnap{
		Version:     version,
		State:       e.Save(),
		DirtyFields: dirtyFields,
		Changes:     changes,
	}
}

func (s *CityEntitySnap) Clone() *CityEntitySnap {
	if s == nil {
		return nil
	}
	out := &CityEntitySnap{Version: s.Version}
	out.State = s.State
	out.DirtyFields = append([]Field(nil), s.DirtyFields...)
	if len(s.Changes) > 0 {
		out.Changes = make(map[Field]CityEntityCollectionChange, len(s.Changes))
		for f, ch := range s.Changes {
			out.Changes[f] = cloneCityEntityCollectionChange(ch)
		}
	}
	return out
}

func (e *CityEntity) CityId() CityID {
	if e == nil {
		var z CityID
		return z
	}
	return e.cityId
}

func (e *CityEntity) SetCityId(v CityID) bool {
	if e == nil {
		return false
	}
	if e.cityId == v {
		return false
	}
	e.cityId = v
	e._dt.mark(FieldCity_cityId)
	return true
}

func (e *CityEntity) Name() string {
	if e == nil {
		var z string
		return z
	}
	return e.name
}

func (e *CityEntity) SetName(v string) bool {
	if e == nil {
		return false
	}
	if e.name == v {
		return false
	}
	e.name = v
	e._dt.mark(FieldCity_name)
	return true
}

func (e *CityEntity) UnionId() int {
	if e == nil {
		var z int
		return z
	}
	return e.unionId
}

func (e *CityEntity) SetUnionId(v int) bool {
	if e == nil {
		return false
	}
	if e.unionId == v {
		return false
	}
	e.unionId = v
	e._dt.mark(FieldCity_unionId)
	return true
}

func (e *CityEntity) UnionName() string {
	if e == nil {
		var z string
		return z
	}
	return e.unionName
}

func (e *CityEntity) SetUnionName(v string) bool {
	if e == nil {
		return false
	}
	if e.unionName == v {
		return false
	}
	e.unionName = v
	e._dt.mark(FieldCity_unionName)
	return true
}

func (e *CityEntity) ParentId() int {
	if e == nil {
		var z int
		return z
	}
	return e.parentId
}

func (e *CityEntity) SetParentId(v int) bool {
	if e == nil {
		return false
	}
	if e.parentId == v {
		return false
	}
	e.parentId = v
	e._dt.mark(FieldCity_parentId)
	return true
}

func (e *CityEntity) X() int {
	if e == nil {
		var z int
		return z
	}
	return e.x
}

func (e *CityEntity) SetX(v int) bool {
	if e == nil {
		return false
	}
	if e.x == v {
		return false
	}
	e.x = v
	e._dt.mark(FieldCity_x)
	return true
}

func (e *CityEntity) Y() int {
	if e == nil {
		var z int
		return z
	}
	return e.y
}

func (e *CityEntity) SetY(v int) bool {
	if e == nil {
		return false
	}
	if e.y == v {
		return false
	}
	e.y = v
	e._dt.mark(FieldCity_y)
	return true
}

func (e *CityEntity) IsMain() bool {
	if e == nil {
		var z bool
		return z
	}
	return e.isMain
}

func (e *CityEntity) SetIsMain(v bool) bool {
	if e == nil {
		return false
	}
	if e.isMain == v {
		return false
	}
	e.isMain = v
	e._dt.mark(FieldCity_isMain)
	return true
}

func (e *CityEntity) Level() int8 {
	if e == nil {
		var z int8
		return z
	}
	return e.level
}

func (e *CityEntity) SetLevel(v int8) bool {
	if e == nil {
		return false
	}
	if e.level == v {
		return false
	}
	e.level = v
	e._dt.mark(FieldCity_level)
	return true
}

func (e *CityEntity) CurDurable() int {
	if e == nil {
		var z int
		return z
	}
	return e.curDurable
}

func (e *CityEntity) SetCurDurable(v int) bool {
	if e == nil {
		return false
	}
	if e.curDurable == v {
		return false
	}
	e.curDurable = v
	e._dt.mark(FieldCity_curDurable)
	return true
}

func (e *CityEntity) MaxDurable() int {
	if e == nil {
		var z int
		return z
	}
	return e.maxDurable
}

func (e *CityEntity) SetMaxDurable(v int) bool {
	if e == nil {
		return false
	}
	if e.maxDurable == v {
		return false
	}
	e.maxDurable = v
	e._dt.mark(FieldCity_maxDurable)
	return true
}

func (e *CityEntity) OccupyTime() time.Time {
	if e == nil {
		var z time.Time
		return z
	}
	return e.occupyTime
}

func (e *CityEntity) SetOccupyTime(v time.Time) bool {
	if e == nil {
		return false
	}
	if e.occupyTime.Equal(v) {
		return false
	}
	e.occupyTime = v
	e._dt.mark(FieldCity_occupyTime)
	return true
}
