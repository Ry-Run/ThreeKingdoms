// Code generated by gen_entities; DO NOT EDIT.
package entity

import (
	"fmt"
	"reflect"
	"sort"
)

const (
	FieldWorld_worldId      Field = "worldId"
	FieldWorld_cityByPlayer Field = "cityByPlayer"
	FieldWorld_worldMap     Field = "worldMap"
)

type WorldEntityCollectionChange struct {
	FullReplace       bool
	MapSet            map[string]any
	MapDeleteKeys     []string
	SliceSet          map[int]any
	SliceAppend       []any
	SliceRemoveAt     []int
	SliceSwapRemoveAt []int
}

type WorldEntityCollectionChangeInner struct {
	fullReplace       bool
	mapSet            map[string]any
	mapDelete         map[string]struct{}
	sliceSet          map[int]any
	sliceAppend       []any
	sliceRemoveAt     []int
	sliceSwapRemoveAt []int
}

type WorldEntityTrace struct {
	dirty   bool
	trace   map[Field]bool
	changes map[Field]*WorldEntityCollectionChangeInner
}

func (t *WorldEntityTrace) mark(f Field) {
	t.dirty = true
	if t.trace == nil {
		t.trace = make(map[Field]bool, 8)
	}
	t.trace[f] = true
}

func (t *WorldEntityTrace) ensureChange(f Field) *WorldEntityCollectionChangeInner {
	if t.changes == nil {
		t.changes = make(map[Field]*WorldEntityCollectionChangeInner, 4)
	}
	ch, ok := t.changes[f]
	if !ok || ch == nil {
		ch = &WorldEntityCollectionChangeInner{}
		t.changes[f] = ch
	}
	return ch
}

func (t *WorldEntityTrace) markFullReplace(f Field) {
	t.mark(f)
	ch := t.ensureChange(f)
	ch.fullReplace = true
	ch.mapSet = nil
	ch.mapDelete = nil
	ch.sliceSet = nil
	ch.sliceAppend = nil
	ch.sliceRemoveAt = nil
	ch.sliceSwapRemoveAt = nil
}

func (t *WorldEntityTrace) markMapSet(f Field, key string, value any) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.mapSet == nil {
		ch.mapSet = make(map[string]any, 4)
	}
	ch.mapSet[key] = value
	if ch.mapDelete != nil {
		delete(ch.mapDelete, key)
	}
}

func (t *WorldEntityTrace) markMapDelete(f Field, key string) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.mapDelete == nil {
		ch.mapDelete = make(map[string]struct{}, 4)
	}
	ch.mapDelete[key] = struct{}{}
	if ch.mapSet != nil {
		delete(ch.mapSet, key)
	}
}

func (t *WorldEntityTrace) markSliceAppend(f Field, values ...any) {
	if len(values) == 0 {
		return
	}
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceAppend = append(ch.sliceAppend, values...)
}

func (t *WorldEntityTrace) markSliceSet(f Field, index int, value any) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.sliceSet == nil {
		ch.sliceSet = make(map[int]any, 4)
	}
	ch.sliceSet[index] = value
}

func (t *WorldEntityTrace) markSliceRemoveAt(f Field, index int) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceRemoveAt = append(ch.sliceRemoveAt, index)
}

func (t *WorldEntityTrace) markSliceSwapRemoveAt(f Field, index int) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceSwapRemoveAt = append(ch.sliceSwapRemoveAt, index)
}

type WorldState struct {
	WorldId      WorldID
	CityByPlayer map[PlayerID]map[CityID]CityState
	WorldMap     []CellState
}

type WorldEntitySnap struct {
	Version     uint64
	State       WorldState
	DirtyFields []Field
	Changes     map[Field]WorldEntityCollectionChange
}

type WorldEntity struct {
	worldId      WorldID
	cityByPlayer map[PlayerID]map[CityID]*CityEntity
	worldMap     []*CellEntity
	_dt          WorldEntityTrace
}

func copyMapValue_cityByPlayer(in map[CityID]CityState) map[CityID]CityState {
	var out map[CityID]CityState
	if in == nil {
		out = nil
	} else {
		out0 := make(map[CityID]CityState, len(in))
		for k1, v2 := range in {
			out0[k1] = v2
		}
		out = out0
	}
	return out
}

func hydrateMapValue_cityByPlayer(in map[CityID]CityState) map[CityID]*CityEntity {
	var out map[CityID]*CityEntity
	if in == nil {
		out = nil
	} else {
		out0 := make(map[CityID]*CityEntity, len(in))
		for k1, v2 := range in {
			out0[k1] = HydrateCityEntity(v2)
		}
		out = out0
	}
	return out
}

func snapshotMapValue_cityByPlayer(in map[CityID]*CityEntity) map[CityID]CityState {
	var out map[CityID]CityState
	if in == nil {
		out = nil
	} else {
		out0 := make(map[CityID]CityState, len(in))
		for k1, v2 := range in {
			if v2 == nil {
				var z CityState
				out0[k1] = z
			} else {
				out0[k1] = v2.Save()
			}
		}
		out = out0
	}
	return out
}

func copyMap_cityByPlayer(in map[PlayerID]map[CityID]CityState) map[PlayerID]map[CityID]CityState {
	if in == nil {
		return nil
	}
	out := make(map[PlayerID]map[CityID]CityState, len(in))
	for k, v := range in {
		out[k] = copyMapValue_cityByPlayer(v)
	}
	return out
}

func mapsEqual_cityByPlayer(a, b map[PlayerID]map[CityID]CityState) bool {
	return reflect.DeepEqual(a, b)
}

func hydrateMap_cityByPlayer(in map[PlayerID]map[CityID]CityState) map[PlayerID]map[CityID]*CityEntity {
	if in == nil {
		return nil
	}
	out := make(map[PlayerID]map[CityID]*CityEntity, len(in))
	for k, v := range in {
		out[k] = hydrateMapValue_cityByPlayer(v)
	}
	return out
}

func snapshotMap_cityByPlayer(in map[PlayerID]map[CityID]*CityEntity) map[PlayerID]map[CityID]CityState {
	if in == nil {
		return nil
	}
	out := make(map[PlayerID]map[CityID]CityState, len(in))
	for k, v := range in {
		var sv map[CityID]CityState
		sv = snapshotMapValue_cityByPlayer(v)
		out[k] = sv
	}
	return out
}

func hydrateSlice_worldMap(in []CellState) []*CellEntity {
	if in == nil {
		return nil
	}
	out := make([]*CellEntity, len(in))
	for i, v := range in {
		out[i] = HydrateCellEntity(v)
	}
	return out
}

func snapshotSlice_worldMap(in []*CellEntity) []CellState {
	if in == nil {
		return nil
	}
	out := make([]CellState, len(in))
	for i, v := range in {
		if v == nil {
			var z CellState
			out[i] = z
			continue
		}
		out[i] = v.Save()
	}
	return out
}

func slicesEqual_worldMap(a, b []CellState) bool {
	if a == nil && b == nil {
		return true
	}
	if (a == nil) != (b == nil) {
		return false
	}
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if !reflect.DeepEqual(a[i], b[i]) {
			return false
		}
	}
	return true
}

func HydrateWorldEntity(s WorldState) *WorldEntity {
	return &WorldEntity{
		worldId:      s.WorldId,
		cityByPlayer: hydrateMap_cityByPlayer(s.CityByPlayer),
		worldMap:     hydrateSlice_worldMap(s.WorldMap),
	}
}

func (e *WorldEntity) Dirty() bool {
	if e == nil {
		return false
	}
	if e._dt.dirty {
		return true
	}
	return false
}

func (e *WorldEntity) ClearDirty() {
	if e == nil {
		return
	}
	e._dt = WorldEntityTrace{}
}

func (e *WorldEntity) DirtyFields() []Field {
	if e == nil {
		return nil
	}
	trace := make(map[Field]bool, len(e._dt.trace)+4)
	for k := range e._dt.trace {
		trace[k] = true
	}
	if len(trace) == 0 {
		return nil
	}
	out := make([]Field, 0, len(trace))
	for k := range trace {
		out = append(out, k)
	}
	sort.Slice(out, func(i, j int) bool { return out[i] < out[j] })
	return out
}

func (e *WorldEntity) DirtyChanges() map[Field]WorldEntityCollectionChange {
	if e == nil || len(e._dt.changes) == 0 {
		return nil
	}
	out := make(map[Field]WorldEntityCollectionChange, len(e._dt.changes))
	for f, ch := range e._dt.changes {
		if ch == nil {
			continue
		}
		item := WorldEntityCollectionChange{
			FullReplace: ch.fullReplace,
		}
		if len(ch.mapSet) > 0 {
			item.MapSet = make(map[string]any, len(ch.mapSet))
			for k, v := range ch.mapSet {
				item.MapSet[k] = v
			}
		}
		if len(ch.mapDelete) > 0 {
			keys := make([]string, 0, len(ch.mapDelete))
			for k := range ch.mapDelete {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			item.MapDeleteKeys = keys
		}
		if len(ch.sliceSet) > 0 {
			item.SliceSet = make(map[int]any, len(ch.sliceSet))
			for idx, v := range ch.sliceSet {
				item.SliceSet[idx] = v
			}
		}
		if len(ch.sliceAppend) > 0 {
			item.SliceAppend = append([]any(nil), ch.sliceAppend...)
		}
		if len(ch.sliceRemoveAt) > 0 {
			item.SliceRemoveAt = append([]int(nil), ch.sliceRemoveAt...)
		}
		if len(ch.sliceSwapRemoveAt) > 0 {
			item.SliceSwapRemoveAt = append([]int(nil), ch.sliceSwapRemoveAt...)
		}
		out[f] = item
	}
	return out
}

func cloneWorldEntityCollectionChange(in WorldEntityCollectionChange) WorldEntityCollectionChange {
	out := in
	if in.MapSet != nil {
		out.MapSet = make(map[string]any, len(in.MapSet))
		for k, v := range in.MapSet {
			out.MapSet[k] = v
		}
	}
	if in.MapDeleteKeys != nil {
		out.MapDeleteKeys = append([]string(nil), in.MapDeleteKeys...)
	}
	if in.SliceSet != nil {
		out.SliceSet = make(map[int]any, len(in.SliceSet))
		for idx, v := range in.SliceSet {
			out.SliceSet[idx] = v
		}
	}
	if in.SliceAppend != nil {
		out.SliceAppend = append([]any(nil), in.SliceAppend...)
	}
	if in.SliceRemoveAt != nil {
		out.SliceRemoveAt = append([]int(nil), in.SliceRemoveAt...)
	}
	if in.SliceSwapRemoveAt != nil {
		out.SliceSwapRemoveAt = append([]int(nil), in.SliceSwapRemoveAt...)
	}
	return out
}

func (e *WorldEntity) Save() WorldState {
	var s WorldState
	if e == nil {
		return s
	}
	s.WorldId = e.worldId
	s.CityByPlayer = snapshotMap_cityByPlayer(e.cityByPlayer)
	s.WorldMap = snapshotSlice_worldMap(e.worldMap)
	return s
}

func NewWorldEntitySnap(version uint64, e *WorldEntity) *WorldEntitySnap {
	if e == nil {
		return nil
	}
	dirtyFields := e.DirtyFields()
	changes := e.DirtyChanges()
	return &WorldEntitySnap{
		Version:     version,
		State:       e.Save(),
		DirtyFields: dirtyFields,
		Changes:     changes,
	}
}

func (s *WorldEntitySnap) Clone() *WorldEntitySnap {
	if s == nil {
		return nil
	}
	out := &WorldEntitySnap{Version: s.Version}
	out.State = s.State
	out.DirtyFields = append([]Field(nil), s.DirtyFields...)
	if len(s.Changes) > 0 {
		out.Changes = make(map[Field]WorldEntityCollectionChange, len(s.Changes))
		for f, ch := range s.Changes {
			out.Changes[f] = cloneWorldEntityCollectionChange(ch)
		}
	}
	out.State.CityByPlayer = copyMap_cityByPlayer(s.State.CityByPlayer)
	out.State.WorldMap = append([]CellState(nil), s.State.WorldMap...)
	return out
}

func (e *WorldEntity) WorldId() WorldID {
	if e == nil {
		var z WorldID
		return z
	}
	return e.worldId
}

func (e *WorldEntity) SetWorldId(v WorldID) bool {
	if e == nil {
		return false
	}
	if e.worldId == v {
		return false
	}
	e.worldId = v
	e._dt.mark(FieldWorld_worldId)
	return true
}

func (e *WorldEntity) GetCityByPlayer(key PlayerID) (map[CityID]CityState, bool) {
	var z map[CityID]CityState
	if e == nil || e.cityByPlayer == nil {
		return z, false
	}
	v, ok := e.cityByPlayer[key]
	if !ok {
		return z, false
	}
	return snapshotMapValue_cityByPlayer(v), true
}

func (e *WorldEntity) LenCityByPlayer() int {
	if e == nil || e.cityByPlayer == nil {
		return 0
	}
	return len(e.cityByPlayer)
}

func (e *WorldEntity) ForEachCityByPlayer(fn func(key PlayerID, value map[CityID]CityState)) {
	if e == nil || e.cityByPlayer == nil || fn == nil {
		return
	}
	for k, v := range e.cityByPlayer {
		fn(k, snapshotMapValue_cityByPlayer(v))
	}
}

func (e *WorldEntity) RangeCityByPlayer(fn func(key PlayerID, value map[CityID]CityState) bool) {
	if e == nil || e.cityByPlayer == nil || fn == nil {
		return
	}
	for k, v := range e.cityByPlayer {
		if !fn(k, snapshotMapValue_cityByPlayer(v)) {
			return
		}
	}
}

func (e *WorldEntity) ReplaceCityByPlayer(v map[PlayerID]map[CityID]CityState) bool {
	if e == nil {
		return false
	}
	if mapsEqual_cityByPlayer(snapshotMap_cityByPlayer(e.cityByPlayer), v) {
		return false
	}
	e.cityByPlayer = hydrateMap_cityByPlayer(v)
	e._dt.markFullReplace(FieldWorld_cityByPlayer)
	return true
}

func (e *WorldEntity) PutCityByPlayer(key PlayerID, value map[CityID]CityState) bool {
	if e == nil {
		return false
	}
	if e.cityByPlayer == nil {
		e.cityByPlayer = make(map[PlayerID]map[CityID]*CityEntity)
	}
	if old, ok := e.cityByPlayer[key]; ok && reflect.DeepEqual(snapshotMapValue_cityByPlayer(old), value) {
		return false
	}
	e.cityByPlayer[key] = hydrateMapValue_cityByPlayer(value)
	e._dt.markMapSet(FieldWorld_cityByPlayer, fmt.Sprint(key), copyMapValue_cityByPlayer(value))
	return true
}

func (e *WorldEntity) PutCityByPlayerMany(entries map[PlayerID]map[CityID]CityState) bool {
	if e == nil || len(entries) == 0 {
		return false
	}
	if e.cityByPlayer == nil {
		e.cityByPlayer = make(map[PlayerID]map[CityID]*CityEntity, len(entries))
	}
	changed := false
	for k, v := range entries {
		if old, ok := e.cityByPlayer[k]; ok && reflect.DeepEqual(snapshotMapValue_cityByPlayer(old), v) {
			continue
		}
		e.cityByPlayer[k] = hydrateMapValue_cityByPlayer(v)
		e._dt.markMapSet(FieldWorld_cityByPlayer, fmt.Sprint(k), copyMapValue_cityByPlayer(v))
		changed = true
	}
	return changed
}

func (e *WorldEntity) UpdateCityByPlayer(key PlayerID, fn func(value map[CityID]*CityEntity)) bool {
	if e == nil || fn == nil || e.cityByPlayer == nil {
		return false
	}
	v, ok := e.cityByPlayer[key]
	if !ok {
		return false
	}
	before := snapshotMapValue_cityByPlayer(v)
	fn(v)
	after := snapshotMapValue_cityByPlayer(v)
	if reflect.DeepEqual(before, after) {
		return false
	}
	e._dt.markMapSet(FieldWorld_cityByPlayer, fmt.Sprint(key), copyMapValue_cityByPlayer(after))
	return true
}

func (e *WorldEntity) DelCityByPlayer(key PlayerID) bool {
	if e == nil || e.cityByPlayer == nil {
		return false
	}
	if _, ok := e.cityByPlayer[key]; !ok {
		return false
	}
	delete(e.cityByPlayer, key)
	e._dt.markMapDelete(FieldWorld_cityByPlayer, fmt.Sprint(key))
	return true
}

func (e *WorldEntity) DelCityByPlayerMany(keys []PlayerID) bool {
	if e == nil || e.cityByPlayer == nil || len(keys) == 0 {
		return false
	}
	changed := false
	for _, key := range keys {
		if _, ok := e.cityByPlayer[key]; !ok {
			continue
		}
		delete(e.cityByPlayer, key)
		e._dt.markMapDelete(FieldWorld_cityByPlayer, fmt.Sprint(key))
		changed = true
	}
	return changed
}

func (e *WorldEntity) ClearCityByPlayer() bool {
	if e == nil {
		return false
	}
	if len(e.cityByPlayer) == 0 {
		return false
	}
	e.cityByPlayer = nil
	e._dt.markFullReplace(FieldWorld_cityByPlayer)
	return true
}

func (e *WorldEntity) LenWorldMap() int {
	if e == nil {
		return 0
	}
	return len(e.worldMap)
}

func (e *WorldEntity) AtWorldMap(index int) (CellState, bool) {
	var z CellState
	if e == nil {
		return z, false
	}
	if index < 0 || index >= len(e.worldMap) {
		return z, false
	}
	v := e.worldMap[index]
	if v == nil {
		return z, true
	}
	return v.Save(), true
}

func (e *WorldEntity) ForEachWorldMap(fn func(index int, value CellState)) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.worldMap {
		var state CellState
		if v != nil {
			state = v.Save()
		}
		fn(i, state)
	}
}

func (e *WorldEntity) RangeWorldMap(fn func(index int, value CellState) bool) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.worldMap {
		var state CellState
		if v != nil {
			state = v.Save()
		}
		if !fn(i, state) {
			return
		}
	}
}

func (e *WorldEntity) ReplaceWorldMap(v []CellState) bool {
	if e == nil {
		return false
	}
	if slicesEqual_worldMap(snapshotSlice_worldMap(e.worldMap), v) {
		return false
	}
	e.worldMap = hydrateSlice_worldMap(v)
	e._dt.markFullReplace(FieldWorld_worldMap)
	return true
}

func (e *WorldEntity) AppendWorldMap(values ...CellState) bool {
	if e == nil || len(values) == 0 {
		return false
	}
	for _, v := range values {
		rv := HydrateCellEntity(v)
		e.worldMap = append(e.worldMap, rv)
		e._dt.markSliceAppend(FieldWorld_worldMap, v)
	}
	return true
}

func (e *WorldEntity) SetWorldMapAt(index int, value CellState) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.worldMap) {
		return false
	}
	var oldState CellState
	if e.worldMap[index] != nil {
		oldState = e.worldMap[index].Save()
	}
	if reflect.DeepEqual(oldState, value) {
		return false
	}
	e.worldMap[index] = HydrateCellEntity(value)
	e._dt.markSliceSet(FieldWorld_worldMap, index, value)
	return true
}

func (e *WorldEntity) UpdateWorldMapAt(index int, fn func(value *CellEntity)) bool {
	if e == nil || fn == nil {
		return false
	}
	if index < 0 || index >= len(e.worldMap) {
		return false
	}
	v := e.worldMap[index]
	if v == nil {
		return false
	}
	before := v.Save()
	fn(v)
	after := v.Save()
	if reflect.DeepEqual(before, after) {
		return false
	}
	e._dt.markSliceSet(FieldWorld_worldMap, index, after)
	return true
}

func (e *WorldEntity) RemoveWorldMapAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.worldMap) {
		return false
	}
	e.worldMap = append(e.worldMap[:index], e.worldMap[index+1:]...)
	e._dt.markSliceRemoveAt(FieldWorld_worldMap, index)
	return true
}

func (e *WorldEntity) SwapRemoveWorldMapAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.worldMap) {
		return false
	}
	last := len(e.worldMap) - 1
	if index != last {
		e.worldMap[index] = e.worldMap[last]
	}
	e.worldMap = e.worldMap[:last]
	e._dt.markSliceSwapRemoveAt(FieldWorld_worldMap, index)
	return true
}

func (e *WorldEntity) ClearWorldMap() bool {
	if e == nil {
		return false
	}
	if len(e.worldMap) == 0 {
		return false
	}
	e.worldMap = nil
	e._dt.markFullReplace(FieldWorld_worldMap)
	return true
}
