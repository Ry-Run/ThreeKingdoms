// Code generated by gen_entities; DO NOT EDIT.
package entity

import (
	"reflect"
	"sort"
	"time"
)

const (
	FieldRoleAttribute_parentId        Field = "parentId"
	FieldRoleAttribute_collectTimes    Field = "collectTimes"
	FieldRoleAttribute_lastCollectTime Field = "lastCollectTime"
	FieldRoleAttribute_posTags         Field = "posTags"
)

type RoleAttributeEntityCollectionChange struct {
	FullReplace       bool
	MapSet            map[string]any
	MapDeleteKeys     []string
	SliceSet          map[int]any
	SliceAppend       []any
	SliceRemoveAt     []int
	SliceSwapRemoveAt []int
}

type RoleAttributeEntityCollectionChangeInner struct {
	fullReplace       bool
	mapSet            map[string]any
	mapDelete         map[string]struct{}
	sliceSet          map[int]any
	sliceAppend       []any
	sliceRemoveAt     []int
	sliceSwapRemoveAt []int
}

type RoleAttributeEntityTrace struct {
	dirty   bool
	trace   map[Field]bool
	changes map[Field]*RoleAttributeEntityCollectionChangeInner
}

func (t *RoleAttributeEntityTrace) mark(f Field) {
	t.dirty = true
	if t.trace == nil {
		t.trace = make(map[Field]bool, 8)
	}
	t.trace[f] = true
}

func (t *RoleAttributeEntityTrace) ensureChange(f Field) *RoleAttributeEntityCollectionChangeInner {
	if t.changes == nil {
		t.changes = make(map[Field]*RoleAttributeEntityCollectionChangeInner, 4)
	}
	ch, ok := t.changes[f]
	if !ok || ch == nil {
		ch = &RoleAttributeEntityCollectionChangeInner{}
		t.changes[f] = ch
	}
	return ch
}

func (t *RoleAttributeEntityTrace) markFullReplace(f Field) {
	t.mark(f)
	ch := t.ensureChange(f)
	ch.fullReplace = true
	ch.mapSet = nil
	ch.mapDelete = nil
	ch.sliceSet = nil
	ch.sliceAppend = nil
	ch.sliceRemoveAt = nil
	ch.sliceSwapRemoveAt = nil
}

func (t *RoleAttributeEntityTrace) markMapSet(f Field, key string, value any) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.mapSet == nil {
		ch.mapSet = make(map[string]any, 4)
	}
	ch.mapSet[key] = value
	if ch.mapDelete != nil {
		delete(ch.mapDelete, key)
	}
}

func (t *RoleAttributeEntityTrace) markMapDelete(f Field, key string) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.mapDelete == nil {
		ch.mapDelete = make(map[string]struct{}, 4)
	}
	ch.mapDelete[key] = struct{}{}
	if ch.mapSet != nil {
		delete(ch.mapSet, key)
	}
}

func (t *RoleAttributeEntityTrace) markSliceAppend(f Field, values ...any) {
	if len(values) == 0 {
		return
	}
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceAppend = append(ch.sliceAppend, values...)
}

func (t *RoleAttributeEntityTrace) markSliceSet(f Field, index int, value any) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.sliceSet == nil {
		ch.sliceSet = make(map[int]any, 4)
	}
	ch.sliceSet[index] = value
}

func (t *RoleAttributeEntityTrace) markSliceRemoveAt(f Field, index int) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceRemoveAt = append(ch.sliceRemoveAt, index)
}

func (t *RoleAttributeEntityTrace) markSliceSwapRemoveAt(f Field, index int) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceSwapRemoveAt = append(ch.sliceSwapRemoveAt, index)
}

type RoleAttributeState struct {
	ParentId        int
	CollectTimes    int8
	LastCollectTime time.Time
	PosTags         []PosTagState
}

type RoleAttributeEntitySnap struct {
	Version     uint64
	State       RoleAttributeState
	DirtyFields []Field
	Changes     map[Field]RoleAttributeEntityCollectionChange
}

type RoleAttributeEntity struct {
	parentId        int
	collectTimes    int8
	lastCollectTime time.Time
	posTags         []*PosTagEntity
	_dt             RoleAttributeEntityTrace
}

func hydrateSlice_posTags(in []PosTagState) []*PosTagEntity {
	if in == nil {
		return nil
	}
	out := make([]*PosTagEntity, len(in))
	for i, v := range in {
		out[i] = HydratePosTagEntity(v)
	}
	return out
}

func snapshotSlice_posTags(in []*PosTagEntity) []PosTagState {
	if in == nil {
		return nil
	}
	out := make([]PosTagState, len(in))
	for i, v := range in {
		if v == nil {
			var z PosTagState
			out[i] = z
			continue
		}
		out[i] = v.Save()
	}
	return out
}

func slicesEqual_posTags(a, b []PosTagState) bool {
	if a == nil && b == nil {
		return true
	}
	if (a == nil) != (b == nil) {
		return false
	}
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if !reflect.DeepEqual(a[i], b[i]) {
			return false
		}
	}
	return true
}

func HydrateRoleAttributeEntity(s RoleAttributeState) *RoleAttributeEntity {
	return &RoleAttributeEntity{
		parentId:        s.ParentId,
		collectTimes:    s.CollectTimes,
		lastCollectTime: s.LastCollectTime,
		posTags:         hydrateSlice_posTags(s.PosTags),
	}
}

func (e *RoleAttributeEntity) Dirty() bool {
	if e == nil {
		return false
	}
	if e._dt.dirty {
		return true
	}
	return false
}

func (e *RoleAttributeEntity) ClearDirty() {
	if e == nil {
		return
	}
	e._dt = RoleAttributeEntityTrace{}
}

func (e *RoleAttributeEntity) DirtyFields() []Field {
	if e == nil {
		return nil
	}
	trace := make(map[Field]bool, len(e._dt.trace)+4)
	for k := range e._dt.trace {
		trace[k] = true
	}
	if len(trace) == 0 {
		return nil
	}
	out := make([]Field, 0, len(trace))
	for k := range trace {
		out = append(out, k)
	}
	sort.Slice(out, func(i, j int) bool { return out[i] < out[j] })
	return out
}

func (e *RoleAttributeEntity) DirtyChanges() map[Field]RoleAttributeEntityCollectionChange {
	if e == nil || len(e._dt.changes) == 0 {
		return nil
	}
	out := make(map[Field]RoleAttributeEntityCollectionChange, len(e._dt.changes))
	for f, ch := range e._dt.changes {
		if ch == nil {
			continue
		}
		item := RoleAttributeEntityCollectionChange{
			FullReplace: ch.fullReplace,
		}
		if len(ch.mapSet) > 0 {
			item.MapSet = make(map[string]any, len(ch.mapSet))
			for k, v := range ch.mapSet {
				item.MapSet[k] = v
			}
		}
		if len(ch.mapDelete) > 0 {
			keys := make([]string, 0, len(ch.mapDelete))
			for k := range ch.mapDelete {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			item.MapDeleteKeys = keys
		}
		if len(ch.sliceSet) > 0 {
			item.SliceSet = make(map[int]any, len(ch.sliceSet))
			for idx, v := range ch.sliceSet {
				item.SliceSet[idx] = v
			}
		}
		if len(ch.sliceAppend) > 0 {
			item.SliceAppend = append([]any(nil), ch.sliceAppend...)
		}
		if len(ch.sliceRemoveAt) > 0 {
			item.SliceRemoveAt = append([]int(nil), ch.sliceRemoveAt...)
		}
		if len(ch.sliceSwapRemoveAt) > 0 {
			item.SliceSwapRemoveAt = append([]int(nil), ch.sliceSwapRemoveAt...)
		}
		out[f] = item
	}
	return out
}

func cloneRoleAttributeEntityCollectionChange(in RoleAttributeEntityCollectionChange) RoleAttributeEntityCollectionChange {
	out := in
	if in.MapSet != nil {
		out.MapSet = make(map[string]any, len(in.MapSet))
		for k, v := range in.MapSet {
			out.MapSet[k] = v
		}
	}
	if in.MapDeleteKeys != nil {
		out.MapDeleteKeys = append([]string(nil), in.MapDeleteKeys...)
	}
	if in.SliceSet != nil {
		out.SliceSet = make(map[int]any, len(in.SliceSet))
		for idx, v := range in.SliceSet {
			out.SliceSet[idx] = v
		}
	}
	if in.SliceAppend != nil {
		out.SliceAppend = append([]any(nil), in.SliceAppend...)
	}
	if in.SliceRemoveAt != nil {
		out.SliceRemoveAt = append([]int(nil), in.SliceRemoveAt...)
	}
	if in.SliceSwapRemoveAt != nil {
		out.SliceSwapRemoveAt = append([]int(nil), in.SliceSwapRemoveAt...)
	}
	return out
}

func (e *RoleAttributeEntity) Save() RoleAttributeState {
	var s RoleAttributeState
	if e == nil {
		return s
	}
	s.ParentId = e.parentId
	s.CollectTimes = e.collectTimes
	s.LastCollectTime = e.lastCollectTime
	s.PosTags = snapshotSlice_posTags(e.posTags)
	return s
}

func NewRoleAttributeEntitySnap(version uint64, e *RoleAttributeEntity) *RoleAttributeEntitySnap {
	if e == nil {
		return nil
	}
	dirtyFields := e.DirtyFields()
	changes := e.DirtyChanges()
	return &RoleAttributeEntitySnap{
		Version:     version,
		State:       e.Save(),
		DirtyFields: dirtyFields,
		Changes:     changes,
	}
}

func (s *RoleAttributeEntitySnap) Clone() *RoleAttributeEntitySnap {
	if s == nil {
		return nil
	}
	out := &RoleAttributeEntitySnap{Version: s.Version}
	out.State = s.State
	out.DirtyFields = append([]Field(nil), s.DirtyFields...)
	if len(s.Changes) > 0 {
		out.Changes = make(map[Field]RoleAttributeEntityCollectionChange, len(s.Changes))
		for f, ch := range s.Changes {
			out.Changes[f] = cloneRoleAttributeEntityCollectionChange(ch)
		}
	}
	out.State.PosTags = append([]PosTagState(nil), s.State.PosTags...)
	return out
}

func (e *RoleAttributeEntity) ParentId() int {
	if e == nil {
		var z int
		return z
	}
	return e.parentId
}

func (e *RoleAttributeEntity) SetParentId(v int) bool {
	if e == nil {
		return false
	}
	if e.parentId == v {
		return false
	}
	e.parentId = v
	e._dt.mark(FieldRoleAttribute_parentId)
	return true
}

func (e *RoleAttributeEntity) CollectTimes() int8 {
	if e == nil {
		var z int8
		return z
	}
	return e.collectTimes
}

func (e *RoleAttributeEntity) SetCollectTimes(v int8) bool {
	if e == nil {
		return false
	}
	if e.collectTimes == v {
		return false
	}
	e.collectTimes = v
	e._dt.mark(FieldRoleAttribute_collectTimes)
	return true
}

func (e *RoleAttributeEntity) LastCollectTime() time.Time {
	if e == nil {
		var z time.Time
		return z
	}
	return e.lastCollectTime
}

func (e *RoleAttributeEntity) SetLastCollectTime(v time.Time) bool {
	if e == nil {
		return false
	}
	if e.lastCollectTime.Equal(v) {
		return false
	}
	e.lastCollectTime = v
	e._dt.mark(FieldRoleAttribute_lastCollectTime)
	return true
}

func (e *RoleAttributeEntity) LenPosTags() int {
	if e == nil {
		return 0
	}
	return len(e.posTags)
}

func (e *RoleAttributeEntity) AtPosTags(index int) (PosTagState, bool) {
	var z PosTagState
	if e == nil {
		return z, false
	}
	if index < 0 || index >= len(e.posTags) {
		return z, false
	}
	v := e.posTags[index]
	if v == nil {
		return z, true
	}
	return v.Save(), true
}

func (e *RoleAttributeEntity) ForEachPosTags(fn func(index int, value PosTagState)) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.posTags {
		var state PosTagState
		if v != nil {
			state = v.Save()
		}
		fn(i, state)
	}
}

func (e *RoleAttributeEntity) RangePosTags(fn func(index int, value PosTagState) bool) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.posTags {
		var state PosTagState
		if v != nil {
			state = v.Save()
		}
		if !fn(i, state) {
			return
		}
	}
}

func (e *RoleAttributeEntity) ReplacePosTags(v []PosTagState) bool {
	if e == nil {
		return false
	}
	if slicesEqual_posTags(snapshotSlice_posTags(e.posTags), v) {
		return false
	}
	e.posTags = hydrateSlice_posTags(v)
	e._dt.markFullReplace(FieldRoleAttribute_posTags)
	return true
}

func (e *RoleAttributeEntity) AppendPosTags(values ...PosTagState) bool {
	if e == nil || len(values) == 0 {
		return false
	}
	for _, v := range values {
		rv := HydratePosTagEntity(v)
		e.posTags = append(e.posTags, rv)
		e._dt.markSliceAppend(FieldRoleAttribute_posTags, v)
	}
	return true
}

func (e *RoleAttributeEntity) SetPosTagsAt(index int, value PosTagState) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.posTags) {
		return false
	}
	var oldState PosTagState
	if e.posTags[index] != nil {
		oldState = e.posTags[index].Save()
	}
	if reflect.DeepEqual(oldState, value) {
		return false
	}
	e.posTags[index] = HydratePosTagEntity(value)
	e._dt.markSliceSet(FieldRoleAttribute_posTags, index, value)
	return true
}

func (e *RoleAttributeEntity) UpdatePosTagsAt(index int, fn func(value *PosTagEntity)) bool {
	if e == nil || fn == nil {
		return false
	}
	if index < 0 || index >= len(e.posTags) {
		return false
	}
	v := e.posTags[index]
	if v == nil {
		return false
	}
	before := v.Save()
	fn(v)
	after := v.Save()
	if reflect.DeepEqual(before, after) {
		return false
	}
	e._dt.markSliceSet(FieldRoleAttribute_posTags, index, after)
	return true
}

func (e *RoleAttributeEntity) RemovePosTagsAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.posTags) {
		return false
	}
	e.posTags = append(e.posTags[:index], e.posTags[index+1:]...)
	e._dt.markSliceRemoveAt(FieldRoleAttribute_posTags, index)
	return true
}

func (e *RoleAttributeEntity) SwapRemovePosTagsAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.posTags) {
		return false
	}
	last := len(e.posTags) - 1
	if index != last {
		e.posTags[index] = e.posTags[last]
	}
	e.posTags = e.posTags[:last]
	e._dt.markSliceSwapRemoveAt(FieldRoleAttribute_posTags, index)
	return true
}

func (e *RoleAttributeEntity) ClearPosTags() bool {
	if e == nil {
		return false
	}
	if len(e.posTags) == 0 {
		return false
	}
	e.posTags = nil
	e._dt.markFullReplace(FieldRoleAttribute_posTags)
	return true
}
