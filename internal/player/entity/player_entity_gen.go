// Code generated by gen_entities; DO NOT EDIT.
package entity

import (
	"fmt"
	"reflect"
	"sort"
)

const (
	FieldPlayer_playerID   Field = "playerID"
	FieldPlayer_worldID    Field = "worldID"
	FieldPlayer_profile    Field = "profile"
	FieldPlayer_resource   Field = "resource"
	FieldPlayer_attribute  Field = "attribute"
	FieldPlayer_x          Field = "x"
	FieldPlayer_y          Field = "y"
	FieldPlayer_buildings  Field = "buildings"
	FieldPlayer_armies     Field = "armies"
	FieldPlayer_generals   Field = "generals"
	FieldPlayer_facility   Field = "facility"
	FieldPlayer_warReports Field = "warReports"
)

type PlayerEntityCollectionChange struct {
	FullReplace       bool
	MapSet            map[string]any
	MapDeleteKeys     []string
	SliceSet          map[int]any
	SliceAppend       []any
	SliceRemoveAt     []int
	SliceSwapRemoveAt []int
}

type PlayerEntityCollectionChangeInner struct {
	fullReplace       bool
	mapSet            map[string]any
	mapDelete         map[string]struct{}
	sliceSet          map[int]any
	sliceAppend       []any
	sliceRemoveAt     []int
	sliceSwapRemoveAt []int
}

type PlayerEntityTrace struct {
	dirty                 bool
	trace                 map[Field]bool
	changes               map[Field]*PlayerEntityCollectionChangeInner
	childDirty_warReports map[int]struct{}
}

func (t *PlayerEntityTrace) mark(f Field) {
	t.dirty = true
	if t.trace == nil {
		t.trace = make(map[Field]bool, 8)
	}
	t.trace[f] = true
}

func (t *PlayerEntityTrace) ensureChange(f Field) *PlayerEntityCollectionChangeInner {
	if t.changes == nil {
		t.changes = make(map[Field]*PlayerEntityCollectionChangeInner, 4)
	}
	ch, ok := t.changes[f]
	if !ok || ch == nil {
		ch = &PlayerEntityCollectionChangeInner{}
		t.changes[f] = ch
	}
	return ch
}

func (t *PlayerEntityTrace) markFullReplace(f Field) {
	t.mark(f)
	ch := t.ensureChange(f)
	ch.fullReplace = true
	ch.mapSet = nil
	ch.mapDelete = nil
	ch.sliceSet = nil
	ch.sliceAppend = nil
	ch.sliceRemoveAt = nil
	ch.sliceSwapRemoveAt = nil
}

func (t *PlayerEntityTrace) markMapSet(f Field, key string, value any) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.mapSet == nil {
		ch.mapSet = make(map[string]any, 4)
	}
	ch.mapSet[key] = value
	if ch.mapDelete != nil {
		delete(ch.mapDelete, key)
	}
}

func (t *PlayerEntityTrace) markMapDelete(f Field, key string) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.mapDelete == nil {
		ch.mapDelete = make(map[string]struct{}, 4)
	}
	ch.mapDelete[key] = struct{}{}
	if ch.mapSet != nil {
		delete(ch.mapSet, key)
	}
}

func (t *PlayerEntityTrace) markSliceAppend(f Field, values ...any) {
	if len(values) == 0 {
		return
	}
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceAppend = append(ch.sliceAppend, values...)
}

func (t *PlayerEntityTrace) markSliceSet(f Field, index int, value any) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.sliceSet == nil {
		ch.sliceSet = make(map[int]any, 4)
	}
	ch.sliceSet[index] = value
}

func (t *PlayerEntityTrace) markSliceRemoveAt(f Field, index int) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceRemoveAt = append(ch.sliceRemoveAt, index)
}

func (t *PlayerEntityTrace) markSliceSwapRemoveAt(f Field, index int) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceSwapRemoveAt = append(ch.sliceSwapRemoveAt, index)
}

func (t *PlayerEntityTrace) markChildDirty_warReports(f Field, key int) {
	t.mark(f)
	if t.childDirty_warReports == nil {
		t.childDirty_warReports = make(map[int]struct{}, 8)
	}
	t.childDirty_warReports[key] = struct{}{}
}

func (t *PlayerEntityTrace) clearChildDirty_warReports(key int) {
	if t.childDirty_warReports == nil {
		return
	}
	delete(t.childDirty_warReports, key)
}

func (t *PlayerEntityTrace) childDirtyKeys_warReports() []int {
	if len(t.childDirty_warReports) == 0 {
		return nil
	}
	out := make([]int, 0, len(t.childDirty_warReports))
	for key := range t.childDirty_warReports {
		out = append(out, key)
	}
	sort.Slice(out, func(i, j int) bool { return fmt.Sprint(out[i]) < fmt.Sprint(out[j]) })
	return out
}

type PlayerState struct {
	PlayerID   PlayerID
	WorldID    WorldID
	Profile    RoleState
	Resource   ResourceState
	Attribute  RoleAttributeState
	X          int
	Y          int
	Buildings  []BuildingState
	Armies     map[CityID][]ArmyState
	Generals   []GeneralState
	Facility   []FacilityState
	WarReports map[int]WarReportState
}

type PlayerEntitySnap struct {
	Version             uint64
	State               PlayerState
	DirtyFields         []Field
	Changes             map[Field]PlayerEntityCollectionChange
	WarReportsDirtyKeys []int
}

type PlayerEntity struct {
	playerID   PlayerID
	worldID    WorldID
	profile    *RoleEntity
	resource   *ResourceEntity
	attribute  *RoleAttributeEntity
	x          int
	y          int
	buildings  []*BuildingEntity
	armies     map[CityID][]*ArmyEntity
	generals   []*GeneralEntity
	facility   []*FacilityEntity
	warReports map[int]*WarReportEntity
	_dt        PlayerEntityTrace
}

func hydrateSlice_buildings(in []BuildingState) []*BuildingEntity {
	if in == nil {
		return nil
	}
	out := make([]*BuildingEntity, len(in))
	for i, v := range in {
		out[i] = HydrateBuildingEntity(v)
	}
	return out
}

func snapshotSlice_buildings(in []*BuildingEntity) []BuildingState {
	if in == nil {
		return nil
	}
	out := make([]BuildingState, len(in))
	for i, v := range in {
		if v == nil {
			var z BuildingState
			out[i] = z
			continue
		}
		out[i] = v.Save()
	}
	return out
}

func slicesEqual_buildings(a, b []BuildingState) bool {
	if a == nil && b == nil {
		return true
	}
	if (a == nil) != (b == nil) {
		return false
	}
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if !reflect.DeepEqual(a[i], b[i]) {
			return false
		}
	}
	return true
}

func copyMapValue_armies(in []ArmyState) []ArmyState {
	var out []ArmyState
	if in == nil {
		out = nil
	} else {
		out0 := make([]ArmyState, len(in))
		for i1, v2 := range in {
			out0[i1] = v2
		}
		out = out0
	}
	return out
}

func hydrateMapValue_armies(in []ArmyState) []*ArmyEntity {
	var out []*ArmyEntity
	if in == nil {
		out = nil
	} else {
		out0 := make([]*ArmyEntity, len(in))
		for i1, v2 := range in {
			out0[i1] = HydrateArmyEntity(v2)
		}
		out = out0
	}
	return out
}

func snapshotMapValue_armies(in []*ArmyEntity) []ArmyState {
	var out []ArmyState
	if in == nil {
		out = nil
	} else {
		out0 := make([]ArmyState, len(in))
		for i1, v2 := range in {
			if v2 == nil {
				var z ArmyState
				out0[i1] = z
			} else {
				out0[i1] = v2.Save()
			}
		}
		out = out0
	}
	return out
}

func copyMap_armies(in map[CityID][]ArmyState) map[CityID][]ArmyState {
	if in == nil {
		return nil
	}
	out := make(map[CityID][]ArmyState, len(in))
	for k, v := range in {
		out[k] = copyMapValue_armies(v)
	}
	return out
}

func mapsEqual_armies(a, b map[CityID][]ArmyState) bool {
	return reflect.DeepEqual(a, b)
}

func hydrateMap_armies(in map[CityID][]ArmyState) map[CityID][]*ArmyEntity {
	if in == nil {
		return nil
	}
	out := make(map[CityID][]*ArmyEntity, len(in))
	for k, v := range in {
		out[k] = hydrateMapValue_armies(v)
	}
	return out
}

func snapshotMap_armies(in map[CityID][]*ArmyEntity) map[CityID][]ArmyState {
	if in == nil {
		return nil
	}
	out := make(map[CityID][]ArmyState, len(in))
	for k, v := range in {
		var sv []ArmyState
		sv = snapshotMapValue_armies(v)
		out[k] = sv
	}
	return out
}

func hydrateSlice_generals(in []GeneralState) []*GeneralEntity {
	if in == nil {
		return nil
	}
	out := make([]*GeneralEntity, len(in))
	for i, v := range in {
		out[i] = HydrateGeneralEntity(v)
	}
	return out
}

func snapshotSlice_generals(in []*GeneralEntity) []GeneralState {
	if in == nil {
		return nil
	}
	out := make([]GeneralState, len(in))
	for i, v := range in {
		if v == nil {
			var z GeneralState
			out[i] = z
			continue
		}
		out[i] = v.Save()
	}
	return out
}

func slicesEqual_generals(a, b []GeneralState) bool {
	if a == nil && b == nil {
		return true
	}
	if (a == nil) != (b == nil) {
		return false
	}
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if !reflect.DeepEqual(a[i], b[i]) {
			return false
		}
	}
	return true
}

func hydrateSlice_facility(in []FacilityState) []*FacilityEntity {
	if in == nil {
		return nil
	}
	out := make([]*FacilityEntity, len(in))
	for i, v := range in {
		out[i] = HydrateFacilityEntity(v)
	}
	return out
}

func snapshotSlice_facility(in []*FacilityEntity) []FacilityState {
	if in == nil {
		return nil
	}
	out := make([]FacilityState, len(in))
	for i, v := range in {
		if v == nil {
			var z FacilityState
			out[i] = z
			continue
		}
		out[i] = v.Save()
	}
	return out
}

func slicesEqual_facility(a, b []FacilityState) bool {
	if a == nil && b == nil {
		return true
	}
	if (a == nil) != (b == nil) {
		return false
	}
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if !reflect.DeepEqual(a[i], b[i]) {
			return false
		}
	}
	return true
}

func copyMap_warReports(in map[int]WarReportState) map[int]WarReportState {
	if in == nil {
		return nil
	}
	out := make(map[int]WarReportState, len(in))
	for k, v := range in {
		out[k] = v
	}
	return out
}

func mapsEqual_warReports(a, b map[int]WarReportState) bool {
	if a == nil && b == nil {
		return true
	}
	return false
}

func hydrateMap_warReports(in map[int]WarReportState) map[int]*WarReportEntity {
	if in == nil {
		return nil
	}
	out := make(map[int]*WarReportEntity, len(in))
	for k, v := range in {
		out[k] = HydrateWarReportEntity(v)
	}
	return out
}

func snapshotMap_warReports(in map[int]*WarReportEntity) map[int]WarReportState {
	if in == nil {
		return nil
	}
	out := make(map[int]WarReportState, len(in))
	for k, v := range in {
		if v == nil {
			var z WarReportState
			out[k] = z
			continue
		}
		out[k] = v.Save()
	}
	return out
}

func HydratePlayerEntity(s PlayerState) *PlayerEntity {
	return &PlayerEntity{
		playerID:   s.PlayerID,
		worldID:    s.WorldID,
		profile:    HydrateRoleEntity(s.Profile),
		resource:   HydrateResourceEntity(s.Resource),
		attribute:  HydrateRoleAttributeEntity(s.Attribute),
		x:          s.X,
		y:          s.Y,
		buildings:  hydrateSlice_buildings(s.Buildings),
		armies:     hydrateMap_armies(s.Armies),
		generals:   hydrateSlice_generals(s.Generals),
		facility:   hydrateSlice_facility(s.Facility),
		warReports: hydrateMap_warReports(s.WarReports),
	}
}

func (e *PlayerEntity) Dirty() bool {
	if e == nil {
		return false
	}
	if e._dt.dirty {
		return true
	}
	if e.profile != nil && e.profile.Dirty() {
		return true
	}
	if e.resource != nil && e.resource.Dirty() {
		return true
	}
	if e.attribute != nil && e.attribute.Dirty() {
		return true
	}
	return false
}

func (e *PlayerEntity) ClearDirty() {
	if e == nil {
		return
	}
	e._dt = PlayerEntityTrace{}
	if e.profile != nil {
		e.profile.ClearDirty()
	}
	if e.resource != nil {
		e.resource.ClearDirty()
	}
	if e.attribute != nil {
		e.attribute.ClearDirty()
	}
}

func (e *PlayerEntity) DirtyFields() []Field {
	if e == nil {
		return nil
	}
	trace := make(map[Field]bool, len(e._dt.trace)+4)
	for k := range e._dt.trace {
		trace[k] = true
	}
	if e.profile != nil && e.profile.Dirty() {
		trace[FieldPlayer_profile] = true
	}
	if e.resource != nil && e.resource.Dirty() {
		trace[FieldPlayer_resource] = true
	}
	if e.attribute != nil && e.attribute.Dirty() {
		trace[FieldPlayer_attribute] = true
	}
	if len(trace) == 0 {
		return nil
	}
	out := make([]Field, 0, len(trace))
	for k := range trace {
		out = append(out, k)
	}
	sort.Slice(out, func(i, j int) bool { return out[i] < out[j] })
	return out
}

func (e *PlayerEntity) DirtyChanges() map[Field]PlayerEntityCollectionChange {
	if e == nil || len(e._dt.changes) == 0 {
		return nil
	}
	out := make(map[Field]PlayerEntityCollectionChange, len(e._dt.changes))
	for f, ch := range e._dt.changes {
		if ch == nil {
			continue
		}
		item := PlayerEntityCollectionChange{
			FullReplace: ch.fullReplace,
		}
		if len(ch.mapSet) > 0 {
			item.MapSet = make(map[string]any, len(ch.mapSet))
			for k, v := range ch.mapSet {
				item.MapSet[k] = v
			}
		}
		if len(ch.mapDelete) > 0 {
			keys := make([]string, 0, len(ch.mapDelete))
			for k := range ch.mapDelete {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			item.MapDeleteKeys = keys
		}
		if len(ch.sliceSet) > 0 {
			item.SliceSet = make(map[int]any, len(ch.sliceSet))
			for idx, v := range ch.sliceSet {
				item.SliceSet[idx] = v
			}
		}
		if len(ch.sliceAppend) > 0 {
			item.SliceAppend = append([]any(nil), ch.sliceAppend...)
		}
		if len(ch.sliceRemoveAt) > 0 {
			item.SliceRemoveAt = append([]int(nil), ch.sliceRemoveAt...)
		}
		if len(ch.sliceSwapRemoveAt) > 0 {
			item.SliceSwapRemoveAt = append([]int(nil), ch.sliceSwapRemoveAt...)
		}
		out[f] = item
	}
	return out
}

func clonePlayerEntityCollectionChange(in PlayerEntityCollectionChange) PlayerEntityCollectionChange {
	out := in
	if in.MapSet != nil {
		out.MapSet = make(map[string]any, len(in.MapSet))
		for k, v := range in.MapSet {
			out.MapSet[k] = v
		}
	}
	if in.MapDeleteKeys != nil {
		out.MapDeleteKeys = append([]string(nil), in.MapDeleteKeys...)
	}
	if in.SliceSet != nil {
		out.SliceSet = make(map[int]any, len(in.SliceSet))
		for idx, v := range in.SliceSet {
			out.SliceSet[idx] = v
		}
	}
	if in.SliceAppend != nil {
		out.SliceAppend = append([]any(nil), in.SliceAppend...)
	}
	if in.SliceRemoveAt != nil {
		out.SliceRemoveAt = append([]int(nil), in.SliceRemoveAt...)
	}
	if in.SliceSwapRemoveAt != nil {
		out.SliceSwapRemoveAt = append([]int(nil), in.SliceSwapRemoveAt...)
	}
	return out
}

func (e *PlayerEntity) Save() PlayerState {
	var s PlayerState
	if e == nil {
		return s
	}
	s.PlayerID = e.playerID
	s.WorldID = e.worldID
	if e.profile != nil {
		s.Profile = e.profile.Save()
	} else {
		var z RoleState
		s.Profile = z
	}
	if e.resource != nil {
		s.Resource = e.resource.Save()
	} else {
		var z ResourceState
		s.Resource = z
	}
	if e.attribute != nil {
		s.Attribute = e.attribute.Save()
	} else {
		var z RoleAttributeState
		s.Attribute = z
	}
	s.X = e.x
	s.Y = e.y
	s.Buildings = snapshotSlice_buildings(e.buildings)
	s.Armies = snapshotMap_armies(e.armies)
	s.Generals = snapshotSlice_generals(e.generals)
	s.Facility = snapshotSlice_facility(e.facility)
	s.WarReports = snapshotMap_warReports(e.warReports)
	return s
}

func NewPlayerEntitySnap(version uint64, e *PlayerEntity) *PlayerEntitySnap {
	if e == nil {
		return nil
	}
	dirtyFields := e.DirtyFields()
	changes := e.DirtyChanges()
	return &PlayerEntitySnap{
		Version:             version,
		State:               e.Save(),
		DirtyFields:         dirtyFields,
		Changes:             changes,
		WarReportsDirtyKeys: e._dt.childDirtyKeys_warReports(),
	}
}

func (s *PlayerEntitySnap) Clone() *PlayerEntitySnap {
	if s == nil {
		return nil
	}
	out := &PlayerEntitySnap{Version: s.Version}
	out.State = s.State
	out.DirtyFields = append([]Field(nil), s.DirtyFields...)
	if len(s.Changes) > 0 {
		out.Changes = make(map[Field]PlayerEntityCollectionChange, len(s.Changes))
		for f, ch := range s.Changes {
			out.Changes[f] = clonePlayerEntityCollectionChange(ch)
		}
	}
	out.WarReportsDirtyKeys = append([]int(nil), s.WarReportsDirtyKeys...)
	out.State.Buildings = append([]BuildingState(nil), s.State.Buildings...)
	out.State.Armies = copyMap_armies(s.State.Armies)
	out.State.Generals = append([]GeneralState(nil), s.State.Generals...)
	out.State.Facility = append([]FacilityState(nil), s.State.Facility...)
	out.State.WarReports = copyMap_warReports(s.State.WarReports)
	return out
}

func (e *PlayerEntity) PlayerID() PlayerID {
	if e == nil {
		var z PlayerID
		return z
	}
	return e.playerID
}

func (e *PlayerEntity) SetPlayerID(v PlayerID) bool {
	if e == nil {
		return false
	}
	if e.playerID == v {
		return false
	}
	e.playerID = v
	e._dt.mark(FieldPlayer_playerID)
	return true
}

func (e *PlayerEntity) WorldID() WorldID {
	if e == nil {
		var z WorldID
		return z
	}
	return e.worldID
}

func (e *PlayerEntity) SetWorldID(v WorldID) bool {
	if e == nil {
		return false
	}
	if e.worldID == v {
		return false
	}
	e.worldID = v
	e._dt.mark(FieldPlayer_worldID)
	return true
}

func (e *PlayerEntity) Profile() *RoleEntity {
	if e == nil {
		return nil
	}
	return e.profile
}

func (e *PlayerEntity) SetProfile(v RoleState) bool {
	if e == nil {
		return false
	}
	next := HydrateRoleEntity(v)
	if e.profile == next {
		return false
	}
	e.profile = next
	e._dt.mark(FieldPlayer_profile)
	return true
}

func (e *PlayerEntity) SetProfileEntity(v *RoleEntity) bool {
	if e == nil {
		return false
	}
	if e.profile == v {
		return false
	}
	e.profile = v
	e._dt.mark(FieldPlayer_profile)
	return true
}

func (e *PlayerEntity) UpdateProfile(fn func(value *RoleEntity)) bool {
	if e == nil || fn == nil {
		return false
	}
	if e.profile == nil {
		e.profile = &RoleEntity{}
	}
	fn(e.profile)
	e._dt.mark(FieldPlayer_profile)
	return true
}

func (e *PlayerEntity) Resource() *ResourceEntity {
	if e == nil {
		return nil
	}
	return e.resource
}

func (e *PlayerEntity) SetResource(v ResourceState) bool {
	if e == nil {
		return false
	}
	next := HydrateResourceEntity(v)
	if e.resource == next {
		return false
	}
	e.resource = next
	e._dt.mark(FieldPlayer_resource)
	return true
}

func (e *PlayerEntity) SetResourceEntity(v *ResourceEntity) bool {
	if e == nil {
		return false
	}
	if e.resource == v {
		return false
	}
	e.resource = v
	e._dt.mark(FieldPlayer_resource)
	return true
}

func (e *PlayerEntity) UpdateResource(fn func(value *ResourceEntity)) bool {
	if e == nil || fn == nil {
		return false
	}
	if e.resource == nil {
		e.resource = &ResourceEntity{}
	}
	fn(e.resource)
	e._dt.mark(FieldPlayer_resource)
	return true
}

func (e *PlayerEntity) Attribute() *RoleAttributeEntity {
	if e == nil {
		return nil
	}
	return e.attribute
}

func (e *PlayerEntity) SetAttribute(v RoleAttributeState) bool {
	if e == nil {
		return false
	}
	next := HydrateRoleAttributeEntity(v)
	if e.attribute == next {
		return false
	}
	e.attribute = next
	e._dt.mark(FieldPlayer_attribute)
	return true
}

func (e *PlayerEntity) SetAttributeEntity(v *RoleAttributeEntity) bool {
	if e == nil {
		return false
	}
	if e.attribute == v {
		return false
	}
	e.attribute = v
	e._dt.mark(FieldPlayer_attribute)
	return true
}

func (e *PlayerEntity) UpdateAttribute(fn func(value *RoleAttributeEntity)) bool {
	if e == nil || fn == nil {
		return false
	}
	if e.attribute == nil {
		e.attribute = &RoleAttributeEntity{}
	}
	fn(e.attribute)
	e._dt.mark(FieldPlayer_attribute)
	return true
}

func (e *PlayerEntity) X() int {
	if e == nil {
		var z int
		return z
	}
	return e.x
}

func (e *PlayerEntity) SetX(v int) bool {
	if e == nil {
		return false
	}
	if e.x == v {
		return false
	}
	e.x = v
	e._dt.mark(FieldPlayer_x)
	return true
}

func (e *PlayerEntity) Y() int {
	if e == nil {
		var z int
		return z
	}
	return e.y
}

func (e *PlayerEntity) SetY(v int) bool {
	if e == nil {
		return false
	}
	if e.y == v {
		return false
	}
	e.y = v
	e._dt.mark(FieldPlayer_y)
	return true
}

func (e *PlayerEntity) LenBuildings() int {
	if e == nil {
		return 0
	}
	return len(e.buildings)
}

func (e *PlayerEntity) AtBuildings(index int) (BuildingState, bool) {
	var z BuildingState
	if e == nil {
		return z, false
	}
	if index < 0 || index >= len(e.buildings) {
		return z, false
	}
	v := e.buildings[index]
	if v == nil {
		return z, true
	}
	return v.Save(), true
}

func (e *PlayerEntity) ForEachBuildings(fn func(index int, value BuildingState)) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.buildings {
		var state BuildingState
		if v != nil {
			state = v.Save()
		}
		fn(i, state)
	}
}

func (e *PlayerEntity) RangeBuildings(fn func(index int, value BuildingState) bool) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.buildings {
		var state BuildingState
		if v != nil {
			state = v.Save()
		}
		if !fn(i, state) {
			return
		}
	}
}

func (e *PlayerEntity) ReplaceBuildings(v []BuildingState) bool {
	if e == nil {
		return false
	}
	if slicesEqual_buildings(snapshotSlice_buildings(e.buildings), v) {
		return false
	}
	e.buildings = hydrateSlice_buildings(v)
	e._dt.markFullReplace(FieldPlayer_buildings)
	return true
}

func (e *PlayerEntity) AppendBuildings(values ...BuildingState) bool {
	if e == nil || len(values) == 0 {
		return false
	}
	for _, v := range values {
		rv := HydrateBuildingEntity(v)
		e.buildings = append(e.buildings, rv)
		e._dt.markSliceAppend(FieldPlayer_buildings, v)
	}
	return true
}

func (e *PlayerEntity) SetBuildingsAt(index int, value BuildingState) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.buildings) {
		return false
	}
	var oldState BuildingState
	if e.buildings[index] != nil {
		oldState = e.buildings[index].Save()
	}
	if reflect.DeepEqual(oldState, value) {
		return false
	}
	e.buildings[index] = HydrateBuildingEntity(value)
	e._dt.markSliceSet(FieldPlayer_buildings, index, value)
	return true
}

func (e *PlayerEntity) UpdateBuildingsAt(index int, fn func(value *BuildingEntity)) bool {
	if e == nil || fn == nil {
		return false
	}
	if index < 0 || index >= len(e.buildings) {
		return false
	}
	v := e.buildings[index]
	if v == nil {
		return false
	}
	before := v.Save()
	fn(v)
	after := v.Save()
	if reflect.DeepEqual(before, after) {
		return false
	}
	e._dt.markSliceSet(FieldPlayer_buildings, index, after)
	return true
}

func (e *PlayerEntity) RemoveBuildingsAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.buildings) {
		return false
	}
	e.buildings = append(e.buildings[:index], e.buildings[index+1:]...)
	e._dt.markSliceRemoveAt(FieldPlayer_buildings, index)
	return true
}

func (e *PlayerEntity) SwapRemoveBuildingsAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.buildings) {
		return false
	}
	last := len(e.buildings) - 1
	if index != last {
		e.buildings[index] = e.buildings[last]
	}
	e.buildings = e.buildings[:last]
	e._dt.markSliceSwapRemoveAt(FieldPlayer_buildings, index)
	return true
}

func (e *PlayerEntity) ClearBuildings() bool {
	if e == nil {
		return false
	}
	if len(e.buildings) == 0 {
		return false
	}
	e.buildings = nil
	e._dt.markFullReplace(FieldPlayer_buildings)
	return true
}

func (e *PlayerEntity) GetArmies(key CityID) ([]ArmyState, bool) {
	var z []ArmyState
	if e == nil || e.armies == nil {
		return z, false
	}
	v, ok := e.armies[key]
	if !ok {
		return z, false
	}
	return snapshotMapValue_armies(v), true
}

func (e *PlayerEntity) LenArmies() int {
	if e == nil || e.armies == nil {
		return 0
	}
	return len(e.armies)
}

func (e *PlayerEntity) ForEachArmies(fn func(key CityID, value []ArmyState)) {
	if e == nil || e.armies == nil || fn == nil {
		return
	}
	for k, v := range e.armies {
		fn(k, snapshotMapValue_armies(v))
	}
}

func (e *PlayerEntity) RangeArmies(fn func(key CityID, value []ArmyState) bool) {
	if e == nil || e.armies == nil || fn == nil {
		return
	}
	for k, v := range e.armies {
		if !fn(k, snapshotMapValue_armies(v)) {
			return
		}
	}
}

func (e *PlayerEntity) ReplaceArmies(v map[CityID][]ArmyState) bool {
	if e == nil {
		return false
	}
	if mapsEqual_armies(snapshotMap_armies(e.armies), v) {
		return false
	}
	e.armies = hydrateMap_armies(v)
	e._dt.markFullReplace(FieldPlayer_armies)
	return true
}

func (e *PlayerEntity) PutArmies(key CityID, value []ArmyState) bool {
	if e == nil {
		return false
	}
	if e.armies == nil {
		e.armies = make(map[CityID][]*ArmyEntity)
	}
	if old, ok := e.armies[key]; ok && reflect.DeepEqual(snapshotMapValue_armies(old), value) {
		return false
	}
	e.armies[key] = hydrateMapValue_armies(value)
	e._dt.markMapSet(FieldPlayer_armies, fmt.Sprint(key), copyMapValue_armies(value))
	return true
}

func (e *PlayerEntity) PutArmiesMany(entries map[CityID][]ArmyState) bool {
	if e == nil || len(entries) == 0 {
		return false
	}
	if e.armies == nil {
		e.armies = make(map[CityID][]*ArmyEntity, len(entries))
	}
	changed := false
	for k, v := range entries {
		if old, ok := e.armies[k]; ok && reflect.DeepEqual(snapshotMapValue_armies(old), v) {
			continue
		}
		e.armies[k] = hydrateMapValue_armies(v)
		e._dt.markMapSet(FieldPlayer_armies, fmt.Sprint(k), copyMapValue_armies(v))
		changed = true
	}
	return changed
}

func (e *PlayerEntity) UpdateArmies(key CityID, fn func(value []*ArmyEntity)) bool {
	if e == nil || fn == nil || e.armies == nil {
		return false
	}
	v, ok := e.armies[key]
	if !ok {
		return false
	}
	before := snapshotMapValue_armies(v)
	fn(v)
	after := snapshotMapValue_armies(v)
	if reflect.DeepEqual(before, after) {
		return false
	}
	e._dt.markMapSet(FieldPlayer_armies, fmt.Sprint(key), copyMapValue_armies(after))
	return true
}

func (e *PlayerEntity) DelArmies(key CityID) bool {
	if e == nil || e.armies == nil {
		return false
	}
	if _, ok := e.armies[key]; !ok {
		return false
	}
	delete(e.armies, key)
	e._dt.markMapDelete(FieldPlayer_armies, fmt.Sprint(key))
	return true
}

func (e *PlayerEntity) DelArmiesMany(keys []CityID) bool {
	if e == nil || e.armies == nil || len(keys) == 0 {
		return false
	}
	changed := false
	for _, key := range keys {
		if _, ok := e.armies[key]; !ok {
			continue
		}
		delete(e.armies, key)
		e._dt.markMapDelete(FieldPlayer_armies, fmt.Sprint(key))
		changed = true
	}
	return changed
}

func (e *PlayerEntity) ClearArmies() bool {
	if e == nil {
		return false
	}
	if len(e.armies) == 0 {
		return false
	}
	e.armies = nil
	e._dt.markFullReplace(FieldPlayer_armies)
	return true
}

func (e *PlayerEntity) LenGenerals() int {
	if e == nil {
		return 0
	}
	return len(e.generals)
}

func (e *PlayerEntity) AtGenerals(index int) (GeneralState, bool) {
	var z GeneralState
	if e == nil {
		return z, false
	}
	if index < 0 || index >= len(e.generals) {
		return z, false
	}
	v := e.generals[index]
	if v == nil {
		return z, true
	}
	return v.Save(), true
}

func (e *PlayerEntity) ForEachGenerals(fn func(index int, value GeneralState)) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.generals {
		var state GeneralState
		if v != nil {
			state = v.Save()
		}
		fn(i, state)
	}
}

func (e *PlayerEntity) RangeGenerals(fn func(index int, value GeneralState) bool) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.generals {
		var state GeneralState
		if v != nil {
			state = v.Save()
		}
		if !fn(i, state) {
			return
		}
	}
}

func (e *PlayerEntity) ReplaceGenerals(v []GeneralState) bool {
	if e == nil {
		return false
	}
	if slicesEqual_generals(snapshotSlice_generals(e.generals), v) {
		return false
	}
	e.generals = hydrateSlice_generals(v)
	e._dt.markFullReplace(FieldPlayer_generals)
	return true
}

func (e *PlayerEntity) AppendGenerals(values ...GeneralState) bool {
	if e == nil || len(values) == 0 {
		return false
	}
	for _, v := range values {
		rv := HydrateGeneralEntity(v)
		e.generals = append(e.generals, rv)
		e._dt.markSliceAppend(FieldPlayer_generals, v)
	}
	return true
}

func (e *PlayerEntity) SetGeneralsAt(index int, value GeneralState) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.generals) {
		return false
	}
	var oldState GeneralState
	if e.generals[index] != nil {
		oldState = e.generals[index].Save()
	}
	if reflect.DeepEqual(oldState, value) {
		return false
	}
	e.generals[index] = HydrateGeneralEntity(value)
	e._dt.markSliceSet(FieldPlayer_generals, index, value)
	return true
}

func (e *PlayerEntity) UpdateGeneralsAt(index int, fn func(value *GeneralEntity)) bool {
	if e == nil || fn == nil {
		return false
	}
	if index < 0 || index >= len(e.generals) {
		return false
	}
	v := e.generals[index]
	if v == nil {
		return false
	}
	before := v.Save()
	fn(v)
	after := v.Save()
	if reflect.DeepEqual(before, after) {
		return false
	}
	e._dt.markSliceSet(FieldPlayer_generals, index, after)
	return true
}

func (e *PlayerEntity) RemoveGeneralsAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.generals) {
		return false
	}
	e.generals = append(e.generals[:index], e.generals[index+1:]...)
	e._dt.markSliceRemoveAt(FieldPlayer_generals, index)
	return true
}

func (e *PlayerEntity) SwapRemoveGeneralsAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.generals) {
		return false
	}
	last := len(e.generals) - 1
	if index != last {
		e.generals[index] = e.generals[last]
	}
	e.generals = e.generals[:last]
	e._dt.markSliceSwapRemoveAt(FieldPlayer_generals, index)
	return true
}

func (e *PlayerEntity) ClearGenerals() bool {
	if e == nil {
		return false
	}
	if len(e.generals) == 0 {
		return false
	}
	e.generals = nil
	e._dt.markFullReplace(FieldPlayer_generals)
	return true
}

func (e *PlayerEntity) LenFacility() int {
	if e == nil {
		return 0
	}
	return len(e.facility)
}

func (e *PlayerEntity) AtFacility(index int) (FacilityState, bool) {
	var z FacilityState
	if e == nil {
		return z, false
	}
	if index < 0 || index >= len(e.facility) {
		return z, false
	}
	v := e.facility[index]
	if v == nil {
		return z, true
	}
	return v.Save(), true
}

func (e *PlayerEntity) ForEachFacility(fn func(index int, value FacilityState)) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.facility {
		var state FacilityState
		if v != nil {
			state = v.Save()
		}
		fn(i, state)
	}
}

func (e *PlayerEntity) RangeFacility(fn func(index int, value FacilityState) bool) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.facility {
		var state FacilityState
		if v != nil {
			state = v.Save()
		}
		if !fn(i, state) {
			return
		}
	}
}

func (e *PlayerEntity) ReplaceFacility(v []FacilityState) bool {
	if e == nil {
		return false
	}
	if slicesEqual_facility(snapshotSlice_facility(e.facility), v) {
		return false
	}
	e.facility = hydrateSlice_facility(v)
	e._dt.markFullReplace(FieldPlayer_facility)
	return true
}

func (e *PlayerEntity) AppendFacility(values ...FacilityState) bool {
	if e == nil || len(values) == 0 {
		return false
	}
	for _, v := range values {
		rv := HydrateFacilityEntity(v)
		e.facility = append(e.facility, rv)
		e._dt.markSliceAppend(FieldPlayer_facility, v)
	}
	return true
}

func (e *PlayerEntity) SetFacilityAt(index int, value FacilityState) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.facility) {
		return false
	}
	var oldState FacilityState
	if e.facility[index] != nil {
		oldState = e.facility[index].Save()
	}
	if reflect.DeepEqual(oldState, value) {
		return false
	}
	e.facility[index] = HydrateFacilityEntity(value)
	e._dt.markSliceSet(FieldPlayer_facility, index, value)
	return true
}

func (e *PlayerEntity) UpdateFacilityAt(index int, fn func(value *FacilityEntity)) bool {
	if e == nil || fn == nil {
		return false
	}
	if index < 0 || index >= len(e.facility) {
		return false
	}
	v := e.facility[index]
	if v == nil {
		return false
	}
	before := v.Save()
	fn(v)
	after := v.Save()
	if reflect.DeepEqual(before, after) {
		return false
	}
	e._dt.markSliceSet(FieldPlayer_facility, index, after)
	return true
}

func (e *PlayerEntity) RemoveFacilityAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.facility) {
		return false
	}
	e.facility = append(e.facility[:index], e.facility[index+1:]...)
	e._dt.markSliceRemoveAt(FieldPlayer_facility, index)
	return true
}

func (e *PlayerEntity) SwapRemoveFacilityAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.facility) {
		return false
	}
	last := len(e.facility) - 1
	if index != last {
		e.facility[index] = e.facility[last]
	}
	e.facility = e.facility[:last]
	e._dt.markSliceSwapRemoveAt(FieldPlayer_facility, index)
	return true
}

func (e *PlayerEntity) ClearFacility() bool {
	if e == nil {
		return false
	}
	if len(e.facility) == 0 {
		return false
	}
	e.facility = nil
	e._dt.markFullReplace(FieldPlayer_facility)
	return true
}

func (e *PlayerEntity) GetWarReports(key int) (WarReportState, bool) {
	var z WarReportState
	if e == nil || e.warReports == nil {
		return z, false
	}
	v, ok := e.warReports[key]
	if !ok || v == nil {
		return z, false
	}
	return v.Save(), true
}

func (e *PlayerEntity) LenWarReports() int {
	if e == nil || e.warReports == nil {
		return 0
	}
	return len(e.warReports)
}

func (e *PlayerEntity) ForEachWarReports(fn func(key int, value WarReportState)) {
	if e == nil || e.warReports == nil || fn == nil {
		return
	}
	for k, v := range e.warReports {
		if v == nil {
			continue
		}
		fn(k, v.Save())
	}
}

func (e *PlayerEntity) RangeWarReports(fn func(key int, value WarReportState) bool) {
	if e == nil || e.warReports == nil || fn == nil {
		return
	}
	for k, v := range e.warReports {
		if v == nil {
			continue
		}
		if !fn(k, v.Save()) {
			return
		}
	}
}

func (e *PlayerEntity) DirtyWarReportsKeys() []int {
	if e == nil {
		return nil
	}
	return e._dt.childDirtyKeys_warReports()
}

func (e *PlayerEntity) ReplaceWarReports(v map[int]WarReportState) bool {
	if e == nil {
		return false
	}
	if mapsEqual_warReports(snapshotMap_warReports(e.warReports), v) {
		return false
	}
	e.warReports = hydrateMap_warReports(v)
	e._dt.markFullReplace(FieldPlayer_warReports)
	return true
}

func (e *PlayerEntity) PutWarReports(key int, value WarReportState) bool {
	if e == nil {
		return false
	}
	if e.warReports == nil {
		e.warReports = make(map[int]*WarReportEntity)
	}
	e.warReports[key] = HydrateWarReportEntity(value)
	e._dt.markMapSet(FieldPlayer_warReports, fmt.Sprint(key), value)
	e._dt.markChildDirty_warReports(FieldPlayer_warReports, key)
	return true
}

func (e *PlayerEntity) PutWarReportsMany(entries map[int]WarReportState) bool {
	if e == nil || len(entries) == 0 {
		return false
	}
	if e.warReports == nil {
		e.warReports = make(map[int]*WarReportEntity, len(entries))
	}
	changed := false
	for k, v := range entries {
		e.warReports[k] = HydrateWarReportEntity(v)
		e._dt.markMapSet(FieldPlayer_warReports, fmt.Sprint(k), v)
		e._dt.markChildDirty_warReports(FieldPlayer_warReports, k)
		changed = true
	}
	return changed
}

func (e *PlayerEntity) UpdateWarReports(key int, fn func(value *WarReportEntity)) bool {
	if e == nil || fn == nil || e.warReports == nil {
		return false
	}
	v, ok := e.warReports[key]
	if !ok || v == nil {
		return false
	}
	fn(v)
	e._dt.markChildDirty_warReports(FieldPlayer_warReports, key)
	return true
}

func (e *PlayerEntity) DelWarReports(key int) bool {
	if e == nil || e.warReports == nil {
		return false
	}
	if _, ok := e.warReports[key]; !ok {
		return false
	}
	delete(e.warReports, key)
	e._dt.markMapDelete(FieldPlayer_warReports, fmt.Sprint(key))
	e._dt.clearChildDirty_warReports(key)
	return true
}

func (e *PlayerEntity) DelWarReportsMany(keys []int) bool {
	if e == nil || e.warReports == nil || len(keys) == 0 {
		return false
	}
	changed := false
	for _, key := range keys {
		if _, ok := e.warReports[key]; !ok {
			continue
		}
		delete(e.warReports, key)
		e._dt.markMapDelete(FieldPlayer_warReports, fmt.Sprint(key))
		e._dt.clearChildDirty_warReports(key)
		changed = true
	}
	return changed
}

func (e *PlayerEntity) ClearWarReports() bool {
	if e == nil {
		return false
	}
	if len(e.warReports) == 0 {
		return false
	}
	e.warReports = nil
	e._dt.markFullReplace(FieldPlayer_warReports)
	e._dt.childDirty_warReports = nil
	return true
}
