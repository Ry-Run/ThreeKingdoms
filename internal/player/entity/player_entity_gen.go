// Code generated by gen_entities; DO NOT EDIT.
package entity

import (
	"reflect"
	"sort"
)

const (
	FieldPlayer_playerID  Field = "playerID"
	FieldPlayer_worldID   Field = "worldID"
	FieldPlayer_profile   Field = "profile"
	FieldPlayer_resource  Field = "resource"
	FieldPlayer_attribute Field = "attribute"
	FieldPlayer_x         Field = "x"
	FieldPlayer_y         Field = "y"
	FieldPlayer_buildings Field = "buildings"
	FieldPlayer_armies    Field = "armies"
	FieldPlayer_generals  Field = "generals"
	FieldPlayer_facility  Field = "facility"
)

type PlayerEntityCollectionChange struct {
	FullReplace       bool
	MapSet            map[string]any
	MapDeleteKeys     []string
	SliceSet          map[int]any
	SliceAppend       []any
	SliceRemoveAt     []int
	SliceSwapRemoveAt []int
}

type PlayerEntityCollectionChangeInner struct {
	fullReplace       bool
	mapSet            map[string]any
	mapDelete         map[string]struct{}
	sliceSet          map[int]any
	sliceAppend       []any
	sliceRemoveAt     []int
	sliceSwapRemoveAt []int
}

type PlayerEntityTrace struct {
	dirty   bool
	trace   map[Field]bool
	changes map[Field]*PlayerEntityCollectionChangeInner
}

func (t *PlayerEntityTrace) mark(f Field) {
	t.dirty = true
	if t.trace == nil {
		t.trace = make(map[Field]bool, 8)
	}
	t.trace[f] = true
}

func (t *PlayerEntityTrace) ensureChange(f Field) *PlayerEntityCollectionChangeInner {
	if t.changes == nil {
		t.changes = make(map[Field]*PlayerEntityCollectionChangeInner, 4)
	}
	ch, ok := t.changes[f]
	if !ok || ch == nil {
		ch = &PlayerEntityCollectionChangeInner{}
		t.changes[f] = ch
	}
	return ch
}

func (t *PlayerEntityTrace) markFullReplace(f Field) {
	t.mark(f)
	ch := t.ensureChange(f)
	ch.fullReplace = true
	ch.mapSet = nil
	ch.mapDelete = nil
	ch.sliceSet = nil
	ch.sliceAppend = nil
	ch.sliceRemoveAt = nil
	ch.sliceSwapRemoveAt = nil
}

func (t *PlayerEntityTrace) markMapSet(f Field, key string, value any) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.mapSet == nil {
		ch.mapSet = make(map[string]any, 4)
	}
	ch.mapSet[key] = value
	if ch.mapDelete != nil {
		delete(ch.mapDelete, key)
	}
}

func (t *PlayerEntityTrace) markMapDelete(f Field, key string) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.mapDelete == nil {
		ch.mapDelete = make(map[string]struct{}, 4)
	}
	ch.mapDelete[key] = struct{}{}
	if ch.mapSet != nil {
		delete(ch.mapSet, key)
	}
}

func (t *PlayerEntityTrace) markSliceAppend(f Field, values ...any) {
	if len(values) == 0 {
		return
	}
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceAppend = append(ch.sliceAppend, values...)
}

func (t *PlayerEntityTrace) markSliceSet(f Field, index int, value any) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.sliceSet == nil {
		ch.sliceSet = make(map[int]any, 4)
	}
	ch.sliceSet[index] = value
}

func (t *PlayerEntityTrace) markSliceRemoveAt(f Field, index int) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceRemoveAt = append(ch.sliceRemoveAt, index)
}

func (t *PlayerEntityTrace) markSliceSwapRemoveAt(f Field, index int) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceSwapRemoveAt = append(ch.sliceSwapRemoveAt, index)
}

type PlayerState struct {
	PlayerID  PlayerID
	WorldID   WorldID
	Profile   RoleState
	Resource  ResourceState
	Attribute RoleAttributeState
	X         int
	Y         int
	Buildings []BuildingState
	Armies    []ArmyState
	Generals  []GeneralState
	Facility  []FacilityState
}

type PlayerEntitySnap struct {
	Version     uint64
	State       PlayerState
	DirtyFields []Field
	Changes     map[Field]PlayerEntityCollectionChange
}

type PlayerEntity struct {
	playerID  PlayerID
	worldID   WorldID
	profile   *RoleEntity
	resource  *ResourceEntity
	attribute *RoleAttributeEntity
	x         int
	y         int
	buildings []*BuildingEntity
	armies    []*ArmyEntity
	generals  []*GeneralEntity
	facility  []*FacilityEntity
	_dt       PlayerEntityTrace
}

func hydrateSlice_buildings(in []BuildingState) []*BuildingEntity {
	if in == nil {
		return nil
	}
	out := make([]*BuildingEntity, len(in))
	for i, v := range in {
		out[i] = HydrateBuildingEntity(v)
	}
	return out
}

func snapshotSlice_buildings(in []*BuildingEntity) []BuildingState {
	if in == nil {
		return nil
	}
	out := make([]BuildingState, len(in))
	for i, v := range in {
		if v == nil {
			var z BuildingState
			out[i] = z
			continue
		}
		out[i] = v.Save()
	}
	return out
}

func slicesEqual_buildings(a, b []BuildingState) bool {
	if a == nil && b == nil {
		return true
	}
	if (a == nil) != (b == nil) {
		return false
	}
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if !reflect.DeepEqual(a[i], b[i]) {
			return false
		}
	}
	return true
}

func hydrateSlice_armies(in []ArmyState) []*ArmyEntity {
	if in == nil {
		return nil
	}
	out := make([]*ArmyEntity, len(in))
	for i, v := range in {
		out[i] = HydrateArmyEntity(v)
	}
	return out
}

func snapshotSlice_armies(in []*ArmyEntity) []ArmyState {
	if in == nil {
		return nil
	}
	out := make([]ArmyState, len(in))
	for i, v := range in {
		if v == nil {
			var z ArmyState
			out[i] = z
			continue
		}
		out[i] = v.Save()
	}
	return out
}

func slicesEqual_armies(a, b []ArmyState) bool {
	if a == nil && b == nil {
		return true
	}
	if (a == nil) != (b == nil) {
		return false
	}
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if !reflect.DeepEqual(a[i], b[i]) {
			return false
		}
	}
	return true
}

func hydrateSlice_generals(in []GeneralState) []*GeneralEntity {
	if in == nil {
		return nil
	}
	out := make([]*GeneralEntity, len(in))
	for i, v := range in {
		out[i] = HydrateGeneralEntity(v)
	}
	return out
}

func snapshotSlice_generals(in []*GeneralEntity) []GeneralState {
	if in == nil {
		return nil
	}
	out := make([]GeneralState, len(in))
	for i, v := range in {
		if v == nil {
			var z GeneralState
			out[i] = z
			continue
		}
		out[i] = v.Save()
	}
	return out
}

func slicesEqual_generals(a, b []GeneralState) bool {
	if a == nil && b == nil {
		return true
	}
	if (a == nil) != (b == nil) {
		return false
	}
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if !reflect.DeepEqual(a[i], b[i]) {
			return false
		}
	}
	return true
}

func hydrateSlice_facility(in []FacilityState) []*FacilityEntity {
	if in == nil {
		return nil
	}
	out := make([]*FacilityEntity, len(in))
	for i, v := range in {
		out[i] = HydrateFacilityEntity(v)
	}
	return out
}

func snapshotSlice_facility(in []*FacilityEntity) []FacilityState {
	if in == nil {
		return nil
	}
	out := make([]FacilityState, len(in))
	for i, v := range in {
		if v == nil {
			var z FacilityState
			out[i] = z
			continue
		}
		out[i] = v.Save()
	}
	return out
}

func slicesEqual_facility(a, b []FacilityState) bool {
	if a == nil && b == nil {
		return true
	}
	if (a == nil) != (b == nil) {
		return false
	}
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if !reflect.DeepEqual(a[i], b[i]) {
			return false
		}
	}
	return true
}

func HydratePlayerEntity(s PlayerState) *PlayerEntity {
	return &PlayerEntity{
		playerID:  s.PlayerID,
		worldID:   s.WorldID,
		profile:   HydrateRoleEntity(s.Profile),
		resource:  HydrateResourceEntity(s.Resource),
		attribute: HydrateRoleAttributeEntity(s.Attribute),
		x:         s.X,
		y:         s.Y,
		buildings: hydrateSlice_buildings(s.Buildings),
		armies:    hydrateSlice_armies(s.Armies),
		generals:  hydrateSlice_generals(s.Generals),
		facility:  hydrateSlice_facility(s.Facility),
	}
}

func (e *PlayerEntity) Dirty() bool {
	if e == nil {
		return false
	}
	if e._dt.dirty {
		return true
	}
	if e.profile != nil && e.profile.Dirty() {
		return true
	}
	if e.resource != nil && e.resource.Dirty() {
		return true
	}
	if e.attribute != nil && e.attribute.Dirty() {
		return true
	}
	return false
}

func (e *PlayerEntity) ClearDirty() {
	if e == nil {
		return
	}
	e._dt = PlayerEntityTrace{}
	if e.profile != nil {
		e.profile.ClearDirty()
	}
	if e.resource != nil {
		e.resource.ClearDirty()
	}
	if e.attribute != nil {
		e.attribute.ClearDirty()
	}
}

func (e *PlayerEntity) DirtyFields() []Field {
	if e == nil {
		return nil
	}
	trace := make(map[Field]bool, len(e._dt.trace)+4)
	for k := range e._dt.trace {
		trace[k] = true
	}
	if e.profile != nil && e.profile.Dirty() {
		trace[FieldPlayer_profile] = true
	}
	if e.resource != nil && e.resource.Dirty() {
		trace[FieldPlayer_resource] = true
	}
	if e.attribute != nil && e.attribute.Dirty() {
		trace[FieldPlayer_attribute] = true
	}
	if len(trace) == 0 {
		return nil
	}
	out := make([]Field, 0, len(trace))
	for k := range trace {
		out = append(out, k)
	}
	sort.Slice(out, func(i, j int) bool { return out[i] < out[j] })
	return out
}

func (e *PlayerEntity) DirtyChanges() map[Field]PlayerEntityCollectionChange {
	if e == nil || len(e._dt.changes) == 0 {
		return nil
	}
	out := make(map[Field]PlayerEntityCollectionChange, len(e._dt.changes))
	for f, ch := range e._dt.changes {
		if ch == nil {
			continue
		}
		item := PlayerEntityCollectionChange{
			FullReplace: ch.fullReplace,
		}
		if len(ch.mapSet) > 0 {
			item.MapSet = make(map[string]any, len(ch.mapSet))
			for k, v := range ch.mapSet {
				item.MapSet[k] = v
			}
		}
		if len(ch.mapDelete) > 0 {
			keys := make([]string, 0, len(ch.mapDelete))
			for k := range ch.mapDelete {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			item.MapDeleteKeys = keys
		}
		if len(ch.sliceSet) > 0 {
			item.SliceSet = make(map[int]any, len(ch.sliceSet))
			for idx, v := range ch.sliceSet {
				item.SliceSet[idx] = v
			}
		}
		if len(ch.sliceAppend) > 0 {
			item.SliceAppend = append([]any(nil), ch.sliceAppend...)
		}
		if len(ch.sliceRemoveAt) > 0 {
			item.SliceRemoveAt = append([]int(nil), ch.sliceRemoveAt...)
		}
		if len(ch.sliceSwapRemoveAt) > 0 {
			item.SliceSwapRemoveAt = append([]int(nil), ch.sliceSwapRemoveAt...)
		}
		out[f] = item
	}
	return out
}

func clonePlayerEntityCollectionChange(in PlayerEntityCollectionChange) PlayerEntityCollectionChange {
	out := in
	if in.MapSet != nil {
		out.MapSet = make(map[string]any, len(in.MapSet))
		for k, v := range in.MapSet {
			out.MapSet[k] = v
		}
	}
	if in.MapDeleteKeys != nil {
		out.MapDeleteKeys = append([]string(nil), in.MapDeleteKeys...)
	}
	if in.SliceSet != nil {
		out.SliceSet = make(map[int]any, len(in.SliceSet))
		for idx, v := range in.SliceSet {
			out.SliceSet[idx] = v
		}
	}
	if in.SliceAppend != nil {
		out.SliceAppend = append([]any(nil), in.SliceAppend...)
	}
	if in.SliceRemoveAt != nil {
		out.SliceRemoveAt = append([]int(nil), in.SliceRemoveAt...)
	}
	if in.SliceSwapRemoveAt != nil {
		out.SliceSwapRemoveAt = append([]int(nil), in.SliceSwapRemoveAt...)
	}
	return out
}

func (e *PlayerEntity) Save() PlayerState {
	var s PlayerState
	if e == nil {
		return s
	}
	s.PlayerID = e.playerID
	s.WorldID = e.worldID
	if e.profile != nil {
		s.Profile = e.profile.Save()
	} else {
		var z RoleState
		s.Profile = z
	}
	if e.resource != nil {
		s.Resource = e.resource.Save()
	} else {
		var z ResourceState
		s.Resource = z
	}
	if e.attribute != nil {
		s.Attribute = e.attribute.Save()
	} else {
		var z RoleAttributeState
		s.Attribute = z
	}
	s.X = e.x
	s.Y = e.y
	s.Buildings = snapshotSlice_buildings(e.buildings)
	s.Armies = snapshotSlice_armies(e.armies)
	s.Generals = snapshotSlice_generals(e.generals)
	s.Facility = snapshotSlice_facility(e.facility)
	return s
}

func NewPlayerEntitySnap(version uint64, e *PlayerEntity) *PlayerEntitySnap {
	if e == nil {
		return nil
	}
	dirtyFields := e.DirtyFields()
	changes := e.DirtyChanges()
	return &PlayerEntitySnap{
		Version:     version,
		State:       e.Save(),
		DirtyFields: dirtyFields,
		Changes:     changes,
	}
}

func (s *PlayerEntitySnap) Clone() *PlayerEntitySnap {
	if s == nil {
		return nil
	}
	out := &PlayerEntitySnap{Version: s.Version}
	out.State = s.State
	out.DirtyFields = append([]Field(nil), s.DirtyFields...)
	if len(s.Changes) > 0 {
		out.Changes = make(map[Field]PlayerEntityCollectionChange, len(s.Changes))
		for f, ch := range s.Changes {
			out.Changes[f] = clonePlayerEntityCollectionChange(ch)
		}
	}
	out.State.Buildings = append([]BuildingState(nil), s.State.Buildings...)
	out.State.Armies = append([]ArmyState(nil), s.State.Armies...)
	out.State.Generals = append([]GeneralState(nil), s.State.Generals...)
	out.State.Facility = append([]FacilityState(nil), s.State.Facility...)
	return out
}

func (e *PlayerEntity) PlayerID() PlayerID {
	if e == nil {
		var z PlayerID
		return z
	}
	return e.playerID
}

func (e *PlayerEntity) SetPlayerID(v PlayerID) bool {
	if e == nil {
		return false
	}
	if e.playerID == v {
		return false
	}
	e.playerID = v
	e._dt.mark(FieldPlayer_playerID)
	return true
}

func (e *PlayerEntity) WorldID() WorldID {
	if e == nil {
		var z WorldID
		return z
	}
	return e.worldID
}

func (e *PlayerEntity) SetWorldID(v WorldID) bool {
	if e == nil {
		return false
	}
	if e.worldID == v {
		return false
	}
	e.worldID = v
	e._dt.mark(FieldPlayer_worldID)
	return true
}

func (e *PlayerEntity) Profile() *RoleEntity {
	if e == nil {
		return nil
	}
	return e.profile
}

func (e *PlayerEntity) SetProfile(v RoleState) bool {
	if e == nil {
		return false
	}
	next := HydrateRoleEntity(v)
	if e.profile == next {
		return false
	}
	e.profile = next
	e._dt.mark(FieldPlayer_profile)
	return true
}

func (e *PlayerEntity) SetProfileEntity(v *RoleEntity) bool {
	if e == nil {
		return false
	}
	if e.profile == v {
		return false
	}
	e.profile = v
	e._dt.mark(FieldPlayer_profile)
	return true
}

func (e *PlayerEntity) UpdateProfile(fn func(value *RoleEntity)) bool {
	if e == nil || fn == nil {
		return false
	}
	if e.profile == nil {
		e.profile = &RoleEntity{}
	}
	fn(e.profile)
	e._dt.mark(FieldPlayer_profile)
	return true
}

func (e *PlayerEntity) Resource() *ResourceEntity {
	if e == nil {
		return nil
	}
	return e.resource
}

func (e *PlayerEntity) SetResource(v ResourceState) bool {
	if e == nil {
		return false
	}
	next := HydrateResourceEntity(v)
	if e.resource == next {
		return false
	}
	e.resource = next
	e._dt.mark(FieldPlayer_resource)
	return true
}

func (e *PlayerEntity) SetResourceEntity(v *ResourceEntity) bool {
	if e == nil {
		return false
	}
	if e.resource == v {
		return false
	}
	e.resource = v
	e._dt.mark(FieldPlayer_resource)
	return true
}

func (e *PlayerEntity) UpdateResource(fn func(value *ResourceEntity)) bool {
	if e == nil || fn == nil {
		return false
	}
	if e.resource == nil {
		e.resource = &ResourceEntity{}
	}
	fn(e.resource)
	e._dt.mark(FieldPlayer_resource)
	return true
}

func (e *PlayerEntity) Attribute() *RoleAttributeEntity {
	if e == nil {
		return nil
	}
	return e.attribute
}

func (e *PlayerEntity) SetAttribute(v RoleAttributeState) bool {
	if e == nil {
		return false
	}
	next := HydrateRoleAttributeEntity(v)
	if e.attribute == next {
		return false
	}
	e.attribute = next
	e._dt.mark(FieldPlayer_attribute)
	return true
}

func (e *PlayerEntity) SetAttributeEntity(v *RoleAttributeEntity) bool {
	if e == nil {
		return false
	}
	if e.attribute == v {
		return false
	}
	e.attribute = v
	e._dt.mark(FieldPlayer_attribute)
	return true
}

func (e *PlayerEntity) UpdateAttribute(fn func(value *RoleAttributeEntity)) bool {
	if e == nil || fn == nil {
		return false
	}
	if e.attribute == nil {
		e.attribute = &RoleAttributeEntity{}
	}
	fn(e.attribute)
	e._dt.mark(FieldPlayer_attribute)
	return true
}

func (e *PlayerEntity) X() int {
	if e == nil {
		var z int
		return z
	}
	return e.x
}

func (e *PlayerEntity) SetX(v int) bool {
	if e == nil {
		return false
	}
	if e.x == v {
		return false
	}
	e.x = v
	e._dt.mark(FieldPlayer_x)
	return true
}

func (e *PlayerEntity) Y() int {
	if e == nil {
		var z int
		return z
	}
	return e.y
}

func (e *PlayerEntity) SetY(v int) bool {
	if e == nil {
		return false
	}
	if e.y == v {
		return false
	}
	e.y = v
	e._dt.mark(FieldPlayer_y)
	return true
}

func (e *PlayerEntity) LenBuildings() int {
	if e == nil {
		return 0
	}
	return len(e.buildings)
}

func (e *PlayerEntity) AtBuildings(index int) (BuildingState, bool) {
	var z BuildingState
	if e == nil {
		return z, false
	}
	if index < 0 || index >= len(e.buildings) {
		return z, false
	}
	v := e.buildings[index]
	if v == nil {
		return z, true
	}
	return v.Save(), true
}

func (e *PlayerEntity) ForEachBuildings(fn func(index int, value BuildingState)) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.buildings {
		var state BuildingState
		if v != nil {
			state = v.Save()
		}
		fn(i, state)
	}
}

func (e *PlayerEntity) RangeBuildings(fn func(index int, value BuildingState) bool) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.buildings {
		var state BuildingState
		if v != nil {
			state = v.Save()
		}
		if !fn(i, state) {
			return
		}
	}
}

func (e *PlayerEntity) ReplaceBuildings(v []BuildingState) bool {
	if e == nil {
		return false
	}
	if slicesEqual_buildings(snapshotSlice_buildings(e.buildings), v) {
		return false
	}
	e.buildings = hydrateSlice_buildings(v)
	e._dt.markFullReplace(FieldPlayer_buildings)
	return true
}

func (e *PlayerEntity) AppendBuildings(values ...BuildingState) bool {
	if e == nil || len(values) == 0 {
		return false
	}
	for _, v := range values {
		rv := HydrateBuildingEntity(v)
		e.buildings = append(e.buildings, rv)
		e._dt.markSliceAppend(FieldPlayer_buildings, v)
	}
	return true
}

func (e *PlayerEntity) SetBuildingsAt(index int, value BuildingState) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.buildings) {
		return false
	}
	var oldState BuildingState
	if e.buildings[index] != nil {
		oldState = e.buildings[index].Save()
	}
	if reflect.DeepEqual(oldState, value) {
		return false
	}
	e.buildings[index] = HydrateBuildingEntity(value)
	e._dt.markSliceSet(FieldPlayer_buildings, index, value)
	return true
}

func (e *PlayerEntity) UpdateBuildingsAt(index int, fn func(value *BuildingEntity)) bool {
	if e == nil || fn == nil {
		return false
	}
	if index < 0 || index >= len(e.buildings) {
		return false
	}
	v := e.buildings[index]
	if v == nil {
		return false
	}
	before := v.Save()
	fn(v)
	after := v.Save()
	if reflect.DeepEqual(before, after) {
		return false
	}
	e._dt.markSliceSet(FieldPlayer_buildings, index, after)
	return true
}

func (e *PlayerEntity) RemoveBuildingsAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.buildings) {
		return false
	}
	e.buildings = append(e.buildings[:index], e.buildings[index+1:]...)
	e._dt.markSliceRemoveAt(FieldPlayer_buildings, index)
	return true
}

func (e *PlayerEntity) SwapRemoveBuildingsAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.buildings) {
		return false
	}
	last := len(e.buildings) - 1
	if index != last {
		e.buildings[index] = e.buildings[last]
	}
	e.buildings = e.buildings[:last]
	e._dt.markSliceSwapRemoveAt(FieldPlayer_buildings, index)
	return true
}

func (e *PlayerEntity) ClearBuildings() bool {
	if e == nil {
		return false
	}
	if len(e.buildings) == 0 {
		return false
	}
	e.buildings = nil
	e._dt.markFullReplace(FieldPlayer_buildings)
	return true
}

func (e *PlayerEntity) LenArmies() int {
	if e == nil {
		return 0
	}
	return len(e.armies)
}

func (e *PlayerEntity) AtArmies(index int) (ArmyState, bool) {
	var z ArmyState
	if e == nil {
		return z, false
	}
	if index < 0 || index >= len(e.armies) {
		return z, false
	}
	v := e.armies[index]
	if v == nil {
		return z, true
	}
	return v.Save(), true
}

func (e *PlayerEntity) ForEachArmies(fn func(index int, value ArmyState)) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.armies {
		var state ArmyState
		if v != nil {
			state = v.Save()
		}
		fn(i, state)
	}
}

func (e *PlayerEntity) RangeArmies(fn func(index int, value ArmyState) bool) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.armies {
		var state ArmyState
		if v != nil {
			state = v.Save()
		}
		if !fn(i, state) {
			return
		}
	}
}

func (e *PlayerEntity) ReplaceArmies(v []ArmyState) bool {
	if e == nil {
		return false
	}
	if slicesEqual_armies(snapshotSlice_armies(e.armies), v) {
		return false
	}
	e.armies = hydrateSlice_armies(v)
	e._dt.markFullReplace(FieldPlayer_armies)
	return true
}

func (e *PlayerEntity) AppendArmies(values ...ArmyState) bool {
	if e == nil || len(values) == 0 {
		return false
	}
	for _, v := range values {
		rv := HydrateArmyEntity(v)
		e.armies = append(e.armies, rv)
		e._dt.markSliceAppend(FieldPlayer_armies, v)
	}
	return true
}

func (e *PlayerEntity) SetArmiesAt(index int, value ArmyState) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.armies) {
		return false
	}
	var oldState ArmyState
	if e.armies[index] != nil {
		oldState = e.armies[index].Save()
	}
	if reflect.DeepEqual(oldState, value) {
		return false
	}
	e.armies[index] = HydrateArmyEntity(value)
	e._dt.markSliceSet(FieldPlayer_armies, index, value)
	return true
}

func (e *PlayerEntity) UpdateArmiesAt(index int, fn func(value *ArmyEntity)) bool {
	if e == nil || fn == nil {
		return false
	}
	if index < 0 || index >= len(e.armies) {
		return false
	}
	v := e.armies[index]
	if v == nil {
		return false
	}
	before := v.Save()
	fn(v)
	after := v.Save()
	if reflect.DeepEqual(before, after) {
		return false
	}
	e._dt.markSliceSet(FieldPlayer_armies, index, after)
	return true
}

func (e *PlayerEntity) RemoveArmiesAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.armies) {
		return false
	}
	e.armies = append(e.armies[:index], e.armies[index+1:]...)
	e._dt.markSliceRemoveAt(FieldPlayer_armies, index)
	return true
}

func (e *PlayerEntity) SwapRemoveArmiesAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.armies) {
		return false
	}
	last := len(e.armies) - 1
	if index != last {
		e.armies[index] = e.armies[last]
	}
	e.armies = e.armies[:last]
	e._dt.markSliceSwapRemoveAt(FieldPlayer_armies, index)
	return true
}

func (e *PlayerEntity) ClearArmies() bool {
	if e == nil {
		return false
	}
	if len(e.armies) == 0 {
		return false
	}
	e.armies = nil
	e._dt.markFullReplace(FieldPlayer_armies)
	return true
}

func (e *PlayerEntity) LenGenerals() int {
	if e == nil {
		return 0
	}
	return len(e.generals)
}

func (e *PlayerEntity) AtGenerals(index int) (GeneralState, bool) {
	var z GeneralState
	if e == nil {
		return z, false
	}
	if index < 0 || index >= len(e.generals) {
		return z, false
	}
	v := e.generals[index]
	if v == nil {
		return z, true
	}
	return v.Save(), true
}

func (e *PlayerEntity) ForEachGenerals(fn func(index int, value GeneralState)) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.generals {
		var state GeneralState
		if v != nil {
			state = v.Save()
		}
		fn(i, state)
	}
}

func (e *PlayerEntity) RangeGenerals(fn func(index int, value GeneralState) bool) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.generals {
		var state GeneralState
		if v != nil {
			state = v.Save()
		}
		if !fn(i, state) {
			return
		}
	}
}

func (e *PlayerEntity) ReplaceGenerals(v []GeneralState) bool {
	if e == nil {
		return false
	}
	if slicesEqual_generals(snapshotSlice_generals(e.generals), v) {
		return false
	}
	e.generals = hydrateSlice_generals(v)
	e._dt.markFullReplace(FieldPlayer_generals)
	return true
}

func (e *PlayerEntity) AppendGenerals(values ...GeneralState) bool {
	if e == nil || len(values) == 0 {
		return false
	}
	for _, v := range values {
		rv := HydrateGeneralEntity(v)
		e.generals = append(e.generals, rv)
		e._dt.markSliceAppend(FieldPlayer_generals, v)
	}
	return true
}

func (e *PlayerEntity) SetGeneralsAt(index int, value GeneralState) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.generals) {
		return false
	}
	var oldState GeneralState
	if e.generals[index] != nil {
		oldState = e.generals[index].Save()
	}
	if reflect.DeepEqual(oldState, value) {
		return false
	}
	e.generals[index] = HydrateGeneralEntity(value)
	e._dt.markSliceSet(FieldPlayer_generals, index, value)
	return true
}

func (e *PlayerEntity) UpdateGeneralsAt(index int, fn func(value *GeneralEntity)) bool {
	if e == nil || fn == nil {
		return false
	}
	if index < 0 || index >= len(e.generals) {
		return false
	}
	v := e.generals[index]
	if v == nil {
		return false
	}
	before := v.Save()
	fn(v)
	after := v.Save()
	if reflect.DeepEqual(before, after) {
		return false
	}
	e._dt.markSliceSet(FieldPlayer_generals, index, after)
	return true
}

func (e *PlayerEntity) RemoveGeneralsAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.generals) {
		return false
	}
	e.generals = append(e.generals[:index], e.generals[index+1:]...)
	e._dt.markSliceRemoveAt(FieldPlayer_generals, index)
	return true
}

func (e *PlayerEntity) SwapRemoveGeneralsAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.generals) {
		return false
	}
	last := len(e.generals) - 1
	if index != last {
		e.generals[index] = e.generals[last]
	}
	e.generals = e.generals[:last]
	e._dt.markSliceSwapRemoveAt(FieldPlayer_generals, index)
	return true
}

func (e *PlayerEntity) ClearGenerals() bool {
	if e == nil {
		return false
	}
	if len(e.generals) == 0 {
		return false
	}
	e.generals = nil
	e._dt.markFullReplace(FieldPlayer_generals)
	return true
}

func (e *PlayerEntity) LenFacility() int {
	if e == nil {
		return 0
	}
	return len(e.facility)
}

func (e *PlayerEntity) AtFacility(index int) (FacilityState, bool) {
	var z FacilityState
	if e == nil {
		return z, false
	}
	if index < 0 || index >= len(e.facility) {
		return z, false
	}
	v := e.facility[index]
	if v == nil {
		return z, true
	}
	return v.Save(), true
}

func (e *PlayerEntity) ForEachFacility(fn func(index int, value FacilityState)) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.facility {
		var state FacilityState
		if v != nil {
			state = v.Save()
		}
		fn(i, state)
	}
}

func (e *PlayerEntity) RangeFacility(fn func(index int, value FacilityState) bool) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.facility {
		var state FacilityState
		if v != nil {
			state = v.Save()
		}
		if !fn(i, state) {
			return
		}
	}
}

func (e *PlayerEntity) ReplaceFacility(v []FacilityState) bool {
	if e == nil {
		return false
	}
	if slicesEqual_facility(snapshotSlice_facility(e.facility), v) {
		return false
	}
	e.facility = hydrateSlice_facility(v)
	e._dt.markFullReplace(FieldPlayer_facility)
	return true
}

func (e *PlayerEntity) AppendFacility(values ...FacilityState) bool {
	if e == nil || len(values) == 0 {
		return false
	}
	for _, v := range values {
		rv := HydrateFacilityEntity(v)
		e.facility = append(e.facility, rv)
		e._dt.markSliceAppend(FieldPlayer_facility, v)
	}
	return true
}

func (e *PlayerEntity) SetFacilityAt(index int, value FacilityState) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.facility) {
		return false
	}
	var oldState FacilityState
	if e.facility[index] != nil {
		oldState = e.facility[index].Save()
	}
	if reflect.DeepEqual(oldState, value) {
		return false
	}
	e.facility[index] = HydrateFacilityEntity(value)
	e._dt.markSliceSet(FieldPlayer_facility, index, value)
	return true
}

func (e *PlayerEntity) UpdateFacilityAt(index int, fn func(value *FacilityEntity)) bool {
	if e == nil || fn == nil {
		return false
	}
	if index < 0 || index >= len(e.facility) {
		return false
	}
	v := e.facility[index]
	if v == nil {
		return false
	}
	before := v.Save()
	fn(v)
	after := v.Save()
	if reflect.DeepEqual(before, after) {
		return false
	}
	e._dt.markSliceSet(FieldPlayer_facility, index, after)
	return true
}

func (e *PlayerEntity) RemoveFacilityAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.facility) {
		return false
	}
	e.facility = append(e.facility[:index], e.facility[index+1:]...)
	e._dt.markSliceRemoveAt(FieldPlayer_facility, index)
	return true
}

func (e *PlayerEntity) SwapRemoveFacilityAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.facility) {
		return false
	}
	last := len(e.facility) - 1
	if index != last {
		e.facility[index] = e.facility[last]
	}
	e.facility = e.facility[:last]
	e._dt.markSliceSwapRemoveAt(FieldPlayer_facility, index)
	return true
}

func (e *PlayerEntity) ClearFacility() bool {
	if e == nil {
		return false
	}
	if len(e.facility) == 0 {
		return false
	}
	e.facility = nil
	e._dt.markFullReplace(FieldPlayer_facility)
	return true
}
