// Code generated by gen_entities; DO NOT EDIT.
package entity

import (
	"reflect"
	"sort"
	"time"
)

const (
	FieldArmy_id                 Field = "id"
	FieldArmy_cityId             Field = "cityId"
	FieldArmy_order              Field = "order"
	FieldArmy_generals           Field = "generals"
	FieldArmy_soldiers           Field = "soldiers"
	FieldArmy_conscriptEndTime   Field = "conscriptEndTime"
	FieldArmy_conscriptQuantity  Field = "conscriptQuantity"
	FieldArmy_cmd                Field = "cmd"
	FieldArmy_fromX              Field = "fromX"
	FieldArmy_fromY              Field = "fromY"
	FieldArmy_toX                Field = "toX"
	FieldArmy_toY                Field = "toY"
	FieldArmy_startTime          Field = "startTime"
	FieldArmy_endTime            Field = "endTime"
	FieldArmy_state              Field = "state"
	FieldArmy_generalArray       Field = "generalArray"
	FieldArmy_soldierArray       Field = "soldierArray"
	FieldArmy_conscriptTimeArray Field = "conscriptTimeArray"
	FieldArmy_conscriptCntArray  Field = "conscriptCntArray"
	FieldArmy_gens               Field = "gens"
	FieldArmy_cellX              Field = "cellX"
	FieldArmy_cellY              Field = "cellY"
)

type ArmyEntityCollectionChange struct {
	FullReplace       bool
	MapSet            map[string]any
	MapDeleteKeys     []string
	SliceSet          map[int]any
	SliceAppend       []any
	SliceRemoveAt     []int
	SliceSwapRemoveAt []int
}

type ArmyEntityCollectionChangeInner struct {
	fullReplace       bool
	mapSet            map[string]any
	mapDelete         map[string]struct{}
	sliceSet          map[int]any
	sliceAppend       []any
	sliceRemoveAt     []int
	sliceSwapRemoveAt []int
}

type ArmyEntityTrace struct {
	dirty   bool
	trace   map[Field]bool
	changes map[Field]*ArmyEntityCollectionChangeInner
}

func (t *ArmyEntityTrace) mark(f Field) {
	t.dirty = true
	if t.trace == nil {
		t.trace = make(map[Field]bool, 8)
	}
	t.trace[f] = true
}

func (t *ArmyEntityTrace) ensureChange(f Field) *ArmyEntityCollectionChangeInner {
	if t.changes == nil {
		t.changes = make(map[Field]*ArmyEntityCollectionChangeInner, 4)
	}
	ch, ok := t.changes[f]
	if !ok || ch == nil {
		ch = &ArmyEntityCollectionChangeInner{}
		t.changes[f] = ch
	}
	return ch
}

func (t *ArmyEntityTrace) markFullReplace(f Field) {
	t.mark(f)
	ch := t.ensureChange(f)
	ch.fullReplace = true
	ch.mapSet = nil
	ch.mapDelete = nil
	ch.sliceSet = nil
	ch.sliceAppend = nil
	ch.sliceRemoveAt = nil
	ch.sliceSwapRemoveAt = nil
}

func (t *ArmyEntityTrace) markMapSet(f Field, key string, value any) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.mapSet == nil {
		ch.mapSet = make(map[string]any, 4)
	}
	ch.mapSet[key] = value
	if ch.mapDelete != nil {
		delete(ch.mapDelete, key)
	}
}

func (t *ArmyEntityTrace) markMapDelete(f Field, key string) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.mapDelete == nil {
		ch.mapDelete = make(map[string]struct{}, 4)
	}
	ch.mapDelete[key] = struct{}{}
	if ch.mapSet != nil {
		delete(ch.mapSet, key)
	}
}

func (t *ArmyEntityTrace) markSliceAppend(f Field, values ...any) {
	if len(values) == 0 {
		return
	}
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceAppend = append(ch.sliceAppend, values...)
}

func (t *ArmyEntityTrace) markSliceSet(f Field, index int, value any) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.sliceSet == nil {
		ch.sliceSet = make(map[int]any, 4)
	}
	ch.sliceSet[index] = value
}

func (t *ArmyEntityTrace) markSliceRemoveAt(f Field, index int) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceRemoveAt = append(ch.sliceRemoveAt, index)
}

func (t *ArmyEntityTrace) markSliceSwapRemoveAt(f Field, index int) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceSwapRemoveAt = append(ch.sliceSwapRemoveAt, index)
}

type ArmyState struct {
	Id                 int
	CityId             CityID
	Order              int8
	Generals           string
	Soldiers           string
	ConscriptEndTime   string
	ConscriptQuantity  string
	Cmd                int8
	FromX              int
	FromY              int
	ToX                int
	ToY                int
	StartTime          time.Time
	EndTime            time.Time
	State              int8
	GeneralArray       []int
	SoldierArray       []int
	ConscriptTimeArray []int64
	ConscriptCntArray  []int
	Gens               []GeneralState
	CellX              int
	CellY              int
}

type ArmyEntitySnap struct {
	Version     uint64
	State       ArmyState
	DirtyFields []Field
	Changes     map[Field]ArmyEntityCollectionChange
}

type ArmyEntity struct {
	id                 int
	cityId             CityID
	order              int8
	generals           string
	soldiers           string
	conscriptEndTime   string
	conscriptQuantity  string
	cmd                int8
	fromX              int
	fromY              int
	toX                int
	toY                int
	startTime          time.Time
	endTime            time.Time
	state              int8
	generalArray       []int
	soldierArray       []int
	conscriptTimeArray []int64
	conscriptCntArray  []int
	gens               []*GeneralEntity
	cellX              int
	cellY              int
	_dt                ArmyEntityTrace
}

func slicesEqual_generalArray(a, b []int) bool {
	if a == nil && b == nil {
		return true
	}
	if (a == nil) != (b == nil) {
		return false
	}
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func slicesEqual_soldierArray(a, b []int) bool {
	if a == nil && b == nil {
		return true
	}
	if (a == nil) != (b == nil) {
		return false
	}
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func slicesEqual_conscriptTimeArray(a, b []int64) bool {
	if a == nil && b == nil {
		return true
	}
	if (a == nil) != (b == nil) {
		return false
	}
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func slicesEqual_conscriptCntArray(a, b []int) bool {
	if a == nil && b == nil {
		return true
	}
	if (a == nil) != (b == nil) {
		return false
	}
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func hydrateSlice_gens(in []GeneralState) []*GeneralEntity {
	if in == nil {
		return nil
	}
	out := make([]*GeneralEntity, len(in))
	for i, v := range in {
		out[i] = HydrateGeneralEntity(v)
	}
	return out
}

func snapshotSlice_gens(in []*GeneralEntity) []GeneralState {
	if in == nil {
		return nil
	}
	out := make([]GeneralState, len(in))
	for i, v := range in {
		if v == nil {
			var z GeneralState
			out[i] = z
			continue
		}
		out[i] = v.Save()
	}
	return out
}

func slicesEqual_gens(a, b []GeneralState) bool {
	if a == nil && b == nil {
		return true
	}
	if (a == nil) != (b == nil) {
		return false
	}
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if !reflect.DeepEqual(a[i], b[i]) {
			return false
		}
	}
	return true
}

func HydrateArmyEntity(s ArmyState) *ArmyEntity {
	return &ArmyEntity{
		id:                 s.Id,
		cityId:             s.CityId,
		order:              s.Order,
		generals:           s.Generals,
		soldiers:           s.Soldiers,
		conscriptEndTime:   s.ConscriptEndTime,
		conscriptQuantity:  s.ConscriptQuantity,
		cmd:                s.Cmd,
		fromX:              s.FromX,
		fromY:              s.FromY,
		toX:                s.ToX,
		toY:                s.ToY,
		startTime:          s.StartTime,
		endTime:            s.EndTime,
		state:              s.State,
		generalArray:       append([]int(nil), s.GeneralArray...),
		soldierArray:       append([]int(nil), s.SoldierArray...),
		conscriptTimeArray: append([]int64(nil), s.ConscriptTimeArray...),
		conscriptCntArray:  append([]int(nil), s.ConscriptCntArray...),
		gens:               hydrateSlice_gens(s.Gens),
		cellX:              s.CellX,
		cellY:              s.CellY,
	}
}

func (e *ArmyEntity) Dirty() bool {
	if e == nil {
		return false
	}
	if e._dt.dirty {
		return true
	}
	return false
}

func (e *ArmyEntity) ClearDirty() {
	if e == nil {
		return
	}
	e._dt = ArmyEntityTrace{}
}

func (e *ArmyEntity) DirtyFields() []Field {
	if e == nil {
		return nil
	}
	trace := make(map[Field]bool, len(e._dt.trace)+4)
	for k := range e._dt.trace {
		trace[k] = true
	}
	if len(trace) == 0 {
		return nil
	}
	out := make([]Field, 0, len(trace))
	for k := range trace {
		out = append(out, k)
	}
	sort.Slice(out, func(i, j int) bool { return out[i] < out[j] })
	return out
}

func (e *ArmyEntity) DirtyChanges() map[Field]ArmyEntityCollectionChange {
	if e == nil || len(e._dt.changes) == 0 {
		return nil
	}
	out := make(map[Field]ArmyEntityCollectionChange, len(e._dt.changes))
	for f, ch := range e._dt.changes {
		if ch == nil {
			continue
		}
		item := ArmyEntityCollectionChange{
			FullReplace: ch.fullReplace,
		}
		if len(ch.mapSet) > 0 {
			item.MapSet = make(map[string]any, len(ch.mapSet))
			for k, v := range ch.mapSet {
				item.MapSet[k] = v
			}
		}
		if len(ch.mapDelete) > 0 {
			keys := make([]string, 0, len(ch.mapDelete))
			for k := range ch.mapDelete {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			item.MapDeleteKeys = keys
		}
		if len(ch.sliceSet) > 0 {
			item.SliceSet = make(map[int]any, len(ch.sliceSet))
			for idx, v := range ch.sliceSet {
				item.SliceSet[idx] = v
			}
		}
		if len(ch.sliceAppend) > 0 {
			item.SliceAppend = append([]any(nil), ch.sliceAppend...)
		}
		if len(ch.sliceRemoveAt) > 0 {
			item.SliceRemoveAt = append([]int(nil), ch.sliceRemoveAt...)
		}
		if len(ch.sliceSwapRemoveAt) > 0 {
			item.SliceSwapRemoveAt = append([]int(nil), ch.sliceSwapRemoveAt...)
		}
		out[f] = item
	}
	return out
}

func cloneArmyEntityCollectionChange(in ArmyEntityCollectionChange) ArmyEntityCollectionChange {
	out := in
	if in.MapSet != nil {
		out.MapSet = make(map[string]any, len(in.MapSet))
		for k, v := range in.MapSet {
			out.MapSet[k] = v
		}
	}
	if in.MapDeleteKeys != nil {
		out.MapDeleteKeys = append([]string(nil), in.MapDeleteKeys...)
	}
	if in.SliceSet != nil {
		out.SliceSet = make(map[int]any, len(in.SliceSet))
		for idx, v := range in.SliceSet {
			out.SliceSet[idx] = v
		}
	}
	if in.SliceAppend != nil {
		out.SliceAppend = append([]any(nil), in.SliceAppend...)
	}
	if in.SliceRemoveAt != nil {
		out.SliceRemoveAt = append([]int(nil), in.SliceRemoveAt...)
	}
	if in.SliceSwapRemoveAt != nil {
		out.SliceSwapRemoveAt = append([]int(nil), in.SliceSwapRemoveAt...)
	}
	return out
}

func (e *ArmyEntity) Save() ArmyState {
	var s ArmyState
	if e == nil {
		return s
	}
	s.Id = e.id
	s.CityId = e.cityId
	s.Order = e.order
	s.Generals = e.generals
	s.Soldiers = e.soldiers
	s.ConscriptEndTime = e.conscriptEndTime
	s.ConscriptQuantity = e.conscriptQuantity
	s.Cmd = e.cmd
	s.FromX = e.fromX
	s.FromY = e.fromY
	s.ToX = e.toX
	s.ToY = e.toY
	s.StartTime = e.startTime
	s.EndTime = e.endTime
	s.State = e.state
	s.GeneralArray = append([]int(nil), e.generalArray...)
	s.SoldierArray = append([]int(nil), e.soldierArray...)
	s.ConscriptTimeArray = append([]int64(nil), e.conscriptTimeArray...)
	s.ConscriptCntArray = append([]int(nil), e.conscriptCntArray...)
	s.Gens = snapshotSlice_gens(e.gens)
	s.CellX = e.cellX
	s.CellY = e.cellY
	return s
}

func NewArmyEntitySnap(version uint64, e *ArmyEntity) *ArmyEntitySnap {
	if e == nil {
		return nil
	}
	dirtyFields := e.DirtyFields()
	changes := e.DirtyChanges()
	return &ArmyEntitySnap{
		Version:     version,
		State:       e.Save(),
		DirtyFields: dirtyFields,
		Changes:     changes,
	}
}

func (s *ArmyEntitySnap) Clone() *ArmyEntitySnap {
	if s == nil {
		return nil
	}
	out := &ArmyEntitySnap{Version: s.Version}
	out.State = s.State
	out.DirtyFields = append([]Field(nil), s.DirtyFields...)
	if len(s.Changes) > 0 {
		out.Changes = make(map[Field]ArmyEntityCollectionChange, len(s.Changes))
		for f, ch := range s.Changes {
			out.Changes[f] = cloneArmyEntityCollectionChange(ch)
		}
	}
	out.State.GeneralArray = append([]int(nil), s.State.GeneralArray...)
	out.State.SoldierArray = append([]int(nil), s.State.SoldierArray...)
	out.State.ConscriptTimeArray = append([]int64(nil), s.State.ConscriptTimeArray...)
	out.State.ConscriptCntArray = append([]int(nil), s.State.ConscriptCntArray...)
	out.State.Gens = append([]GeneralState(nil), s.State.Gens...)
	return out
}

func (e *ArmyEntity) Id() int {
	if e == nil {
		var z int
		return z
	}
	return e.id
}

func (e *ArmyEntity) SetId(v int) bool {
	if e == nil {
		return false
	}
	if e.id == v {
		return false
	}
	e.id = v
	e._dt.mark(FieldArmy_id)
	return true
}

func (e *ArmyEntity) CityId() CityID {
	if e == nil {
		var z CityID
		return z
	}
	return e.cityId
}

func (e *ArmyEntity) SetCityId(v CityID) bool {
	if e == nil {
		return false
	}
	if e.cityId == v {
		return false
	}
	e.cityId = v
	e._dt.mark(FieldArmy_cityId)
	return true
}

func (e *ArmyEntity) Order() int8 {
	if e == nil {
		var z int8
		return z
	}
	return e.order
}

func (e *ArmyEntity) SetOrder(v int8) bool {
	if e == nil {
		return false
	}
	if e.order == v {
		return false
	}
	e.order = v
	e._dt.mark(FieldArmy_order)
	return true
}

func (e *ArmyEntity) Generals() string {
	if e == nil {
		var z string
		return z
	}
	return e.generals
}

func (e *ArmyEntity) SetGenerals(v string) bool {
	if e == nil {
		return false
	}
	if e.generals == v {
		return false
	}
	e.generals = v
	e._dt.mark(FieldArmy_generals)
	return true
}

func (e *ArmyEntity) Soldiers() string {
	if e == nil {
		var z string
		return z
	}
	return e.soldiers
}

func (e *ArmyEntity) SetSoldiers(v string) bool {
	if e == nil {
		return false
	}
	if e.soldiers == v {
		return false
	}
	e.soldiers = v
	e._dt.mark(FieldArmy_soldiers)
	return true
}

func (e *ArmyEntity) ConscriptEndTime() string {
	if e == nil {
		var z string
		return z
	}
	return e.conscriptEndTime
}

func (e *ArmyEntity) SetConscriptEndTime(v string) bool {
	if e == nil {
		return false
	}
	if e.conscriptEndTime == v {
		return false
	}
	e.conscriptEndTime = v
	e._dt.mark(FieldArmy_conscriptEndTime)
	return true
}

func (e *ArmyEntity) ConscriptQuantity() string {
	if e == nil {
		var z string
		return z
	}
	return e.conscriptQuantity
}

func (e *ArmyEntity) SetConscriptQuantity(v string) bool {
	if e == nil {
		return false
	}
	if e.conscriptQuantity == v {
		return false
	}
	e.conscriptQuantity = v
	e._dt.mark(FieldArmy_conscriptQuantity)
	return true
}

func (e *ArmyEntity) Cmd() int8 {
	if e == nil {
		var z int8
		return z
	}
	return e.cmd
}

func (e *ArmyEntity) SetCmd(v int8) bool {
	if e == nil {
		return false
	}
	if e.cmd == v {
		return false
	}
	e.cmd = v
	e._dt.mark(FieldArmy_cmd)
	return true
}

func (e *ArmyEntity) FromX() int {
	if e == nil {
		var z int
		return z
	}
	return e.fromX
}

func (e *ArmyEntity) SetFromX(v int) bool {
	if e == nil {
		return false
	}
	if e.fromX == v {
		return false
	}
	e.fromX = v
	e._dt.mark(FieldArmy_fromX)
	return true
}

func (e *ArmyEntity) FromY() int {
	if e == nil {
		var z int
		return z
	}
	return e.fromY
}

func (e *ArmyEntity) SetFromY(v int) bool {
	if e == nil {
		return false
	}
	if e.fromY == v {
		return false
	}
	e.fromY = v
	e._dt.mark(FieldArmy_fromY)
	return true
}

func (e *ArmyEntity) ToX() int {
	if e == nil {
		var z int
		return z
	}
	return e.toX
}

func (e *ArmyEntity) SetToX(v int) bool {
	if e == nil {
		return false
	}
	if e.toX == v {
		return false
	}
	e.toX = v
	e._dt.mark(FieldArmy_toX)
	return true
}

func (e *ArmyEntity) ToY() int {
	if e == nil {
		var z int
		return z
	}
	return e.toY
}

func (e *ArmyEntity) SetToY(v int) bool {
	if e == nil {
		return false
	}
	if e.toY == v {
		return false
	}
	e.toY = v
	e._dt.mark(FieldArmy_toY)
	return true
}

func (e *ArmyEntity) StartTime() time.Time {
	if e == nil {
		var z time.Time
		return z
	}
	return e.startTime
}

func (e *ArmyEntity) SetStartTime(v time.Time) bool {
	if e == nil {
		return false
	}
	if e.startTime.Equal(v) {
		return false
	}
	e.startTime = v
	e._dt.mark(FieldArmy_startTime)
	return true
}

func (e *ArmyEntity) EndTime() time.Time {
	if e == nil {
		var z time.Time
		return z
	}
	return e.endTime
}

func (e *ArmyEntity) SetEndTime(v time.Time) bool {
	if e == nil {
		return false
	}
	if e.endTime.Equal(v) {
		return false
	}
	e.endTime = v
	e._dt.mark(FieldArmy_endTime)
	return true
}

func (e *ArmyEntity) State() int8 {
	if e == nil {
		var z int8
		return z
	}
	return e.state
}

func (e *ArmyEntity) SetState(v int8) bool {
	if e == nil {
		return false
	}
	if e.state == v {
		return false
	}
	e.state = v
	e._dt.mark(FieldArmy_state)
	return true
}

func (e *ArmyEntity) LenGeneralArray() int {
	if e == nil {
		return 0
	}
	return len(e.generalArray)
}

func (e *ArmyEntity) AtGeneralArray(index int) (int, bool) {
	var z int
	if e == nil {
		return z, false
	}
	if index < 0 || index >= len(e.generalArray) {
		return z, false
	}
	return e.generalArray[index], true
}

func (e *ArmyEntity) ForEachGeneralArray(fn func(index int, value int)) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.generalArray {
		fn(i, v)
	}
}

func (e *ArmyEntity) RangeGeneralArray(fn func(index int, value int) bool) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.generalArray {
		if !fn(i, v) {
			return
		}
	}
}

func (e *ArmyEntity) ReplaceGeneralArray(v []int) bool {
	if e == nil {
		return false
	}
	if slicesEqual_generalArray(e.generalArray, v) {
		return false
	}
	e.generalArray = append([]int(nil), v...)
	e._dt.markFullReplace(FieldArmy_generalArray)
	return true
}

func (e *ArmyEntity) AppendGeneralArray(values ...int) bool {
	if e == nil || len(values) == 0 {
		return false
	}
	e.generalArray = append(e.generalArray, values...)
	for _, v := range values {
		e._dt.markSliceAppend(FieldArmy_generalArray, v)
	}
	return true
}

func (e *ArmyEntity) SetGeneralArrayAt(index int, value int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.generalArray) {
		return false
	}
	if e.generalArray[index] == value {
		return false
	}
	e.generalArray[index] = value
	e._dt.markSliceSet(FieldArmy_generalArray, index, value)
	return true
}

func (e *ArmyEntity) RemoveGeneralArrayAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.generalArray) {
		return false
	}
	e.generalArray = append(e.generalArray[:index], e.generalArray[index+1:]...)
	e._dt.markSliceRemoveAt(FieldArmy_generalArray, index)
	return true
}

func (e *ArmyEntity) SwapRemoveGeneralArrayAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.generalArray) {
		return false
	}
	last := len(e.generalArray) - 1
	if index != last {
		e.generalArray[index] = e.generalArray[last]
	}
	e.generalArray = e.generalArray[:last]
	e._dt.markSliceSwapRemoveAt(FieldArmy_generalArray, index)
	return true
}

func (e *ArmyEntity) ClearGeneralArray() bool {
	if e == nil {
		return false
	}
	if len(e.generalArray) == 0 {
		return false
	}
	e.generalArray = nil
	e._dt.markFullReplace(FieldArmy_generalArray)
	return true
}

func (e *ArmyEntity) LenSoldierArray() int {
	if e == nil {
		return 0
	}
	return len(e.soldierArray)
}

func (e *ArmyEntity) AtSoldierArray(index int) (int, bool) {
	var z int
	if e == nil {
		return z, false
	}
	if index < 0 || index >= len(e.soldierArray) {
		return z, false
	}
	return e.soldierArray[index], true
}

func (e *ArmyEntity) ForEachSoldierArray(fn func(index int, value int)) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.soldierArray {
		fn(i, v)
	}
}

func (e *ArmyEntity) RangeSoldierArray(fn func(index int, value int) bool) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.soldierArray {
		if !fn(i, v) {
			return
		}
	}
}

func (e *ArmyEntity) ReplaceSoldierArray(v []int) bool {
	if e == nil {
		return false
	}
	if slicesEqual_soldierArray(e.soldierArray, v) {
		return false
	}
	e.soldierArray = append([]int(nil), v...)
	e._dt.markFullReplace(FieldArmy_soldierArray)
	return true
}

func (e *ArmyEntity) AppendSoldierArray(values ...int) bool {
	if e == nil || len(values) == 0 {
		return false
	}
	e.soldierArray = append(e.soldierArray, values...)
	for _, v := range values {
		e._dt.markSliceAppend(FieldArmy_soldierArray, v)
	}
	return true
}

func (e *ArmyEntity) SetSoldierArrayAt(index int, value int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.soldierArray) {
		return false
	}
	if e.soldierArray[index] == value {
		return false
	}
	e.soldierArray[index] = value
	e._dt.markSliceSet(FieldArmy_soldierArray, index, value)
	return true
}

func (e *ArmyEntity) RemoveSoldierArrayAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.soldierArray) {
		return false
	}
	e.soldierArray = append(e.soldierArray[:index], e.soldierArray[index+1:]...)
	e._dt.markSliceRemoveAt(FieldArmy_soldierArray, index)
	return true
}

func (e *ArmyEntity) SwapRemoveSoldierArrayAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.soldierArray) {
		return false
	}
	last := len(e.soldierArray) - 1
	if index != last {
		e.soldierArray[index] = e.soldierArray[last]
	}
	e.soldierArray = e.soldierArray[:last]
	e._dt.markSliceSwapRemoveAt(FieldArmy_soldierArray, index)
	return true
}

func (e *ArmyEntity) ClearSoldierArray() bool {
	if e == nil {
		return false
	}
	if len(e.soldierArray) == 0 {
		return false
	}
	e.soldierArray = nil
	e._dt.markFullReplace(FieldArmy_soldierArray)
	return true
}

func (e *ArmyEntity) LenConscriptTimeArray() int {
	if e == nil {
		return 0
	}
	return len(e.conscriptTimeArray)
}

func (e *ArmyEntity) AtConscriptTimeArray(index int) (int64, bool) {
	var z int64
	if e == nil {
		return z, false
	}
	if index < 0 || index >= len(e.conscriptTimeArray) {
		return z, false
	}
	return e.conscriptTimeArray[index], true
}

func (e *ArmyEntity) ForEachConscriptTimeArray(fn func(index int, value int64)) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.conscriptTimeArray {
		fn(i, v)
	}
}

func (e *ArmyEntity) RangeConscriptTimeArray(fn func(index int, value int64) bool) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.conscriptTimeArray {
		if !fn(i, v) {
			return
		}
	}
}

func (e *ArmyEntity) ReplaceConscriptTimeArray(v []int64) bool {
	if e == nil {
		return false
	}
	if slicesEqual_conscriptTimeArray(e.conscriptTimeArray, v) {
		return false
	}
	e.conscriptTimeArray = append([]int64(nil), v...)
	e._dt.markFullReplace(FieldArmy_conscriptTimeArray)
	return true
}

func (e *ArmyEntity) AppendConscriptTimeArray(values ...int64) bool {
	if e == nil || len(values) == 0 {
		return false
	}
	e.conscriptTimeArray = append(e.conscriptTimeArray, values...)
	for _, v := range values {
		e._dt.markSliceAppend(FieldArmy_conscriptTimeArray, v)
	}
	return true
}

func (e *ArmyEntity) SetConscriptTimeArrayAt(index int, value int64) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.conscriptTimeArray) {
		return false
	}
	if e.conscriptTimeArray[index] == value {
		return false
	}
	e.conscriptTimeArray[index] = value
	e._dt.markSliceSet(FieldArmy_conscriptTimeArray, index, value)
	return true
}

func (e *ArmyEntity) RemoveConscriptTimeArrayAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.conscriptTimeArray) {
		return false
	}
	e.conscriptTimeArray = append(e.conscriptTimeArray[:index], e.conscriptTimeArray[index+1:]...)
	e._dt.markSliceRemoveAt(FieldArmy_conscriptTimeArray, index)
	return true
}

func (e *ArmyEntity) SwapRemoveConscriptTimeArrayAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.conscriptTimeArray) {
		return false
	}
	last := len(e.conscriptTimeArray) - 1
	if index != last {
		e.conscriptTimeArray[index] = e.conscriptTimeArray[last]
	}
	e.conscriptTimeArray = e.conscriptTimeArray[:last]
	e._dt.markSliceSwapRemoveAt(FieldArmy_conscriptTimeArray, index)
	return true
}

func (e *ArmyEntity) ClearConscriptTimeArray() bool {
	if e == nil {
		return false
	}
	if len(e.conscriptTimeArray) == 0 {
		return false
	}
	e.conscriptTimeArray = nil
	e._dt.markFullReplace(FieldArmy_conscriptTimeArray)
	return true
}

func (e *ArmyEntity) LenConscriptCntArray() int {
	if e == nil {
		return 0
	}
	return len(e.conscriptCntArray)
}

func (e *ArmyEntity) AtConscriptCntArray(index int) (int, bool) {
	var z int
	if e == nil {
		return z, false
	}
	if index < 0 || index >= len(e.conscriptCntArray) {
		return z, false
	}
	return e.conscriptCntArray[index], true
}

func (e *ArmyEntity) ForEachConscriptCntArray(fn func(index int, value int)) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.conscriptCntArray {
		fn(i, v)
	}
}

func (e *ArmyEntity) RangeConscriptCntArray(fn func(index int, value int) bool) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.conscriptCntArray {
		if !fn(i, v) {
			return
		}
	}
}

func (e *ArmyEntity) ReplaceConscriptCntArray(v []int) bool {
	if e == nil {
		return false
	}
	if slicesEqual_conscriptCntArray(e.conscriptCntArray, v) {
		return false
	}
	e.conscriptCntArray = append([]int(nil), v...)
	e._dt.markFullReplace(FieldArmy_conscriptCntArray)
	return true
}

func (e *ArmyEntity) AppendConscriptCntArray(values ...int) bool {
	if e == nil || len(values) == 0 {
		return false
	}
	e.conscriptCntArray = append(e.conscriptCntArray, values...)
	for _, v := range values {
		e._dt.markSliceAppend(FieldArmy_conscriptCntArray, v)
	}
	return true
}

func (e *ArmyEntity) SetConscriptCntArrayAt(index int, value int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.conscriptCntArray) {
		return false
	}
	if e.conscriptCntArray[index] == value {
		return false
	}
	e.conscriptCntArray[index] = value
	e._dt.markSliceSet(FieldArmy_conscriptCntArray, index, value)
	return true
}

func (e *ArmyEntity) RemoveConscriptCntArrayAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.conscriptCntArray) {
		return false
	}
	e.conscriptCntArray = append(e.conscriptCntArray[:index], e.conscriptCntArray[index+1:]...)
	e._dt.markSliceRemoveAt(FieldArmy_conscriptCntArray, index)
	return true
}

func (e *ArmyEntity) SwapRemoveConscriptCntArrayAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.conscriptCntArray) {
		return false
	}
	last := len(e.conscriptCntArray) - 1
	if index != last {
		e.conscriptCntArray[index] = e.conscriptCntArray[last]
	}
	e.conscriptCntArray = e.conscriptCntArray[:last]
	e._dt.markSliceSwapRemoveAt(FieldArmy_conscriptCntArray, index)
	return true
}

func (e *ArmyEntity) ClearConscriptCntArray() bool {
	if e == nil {
		return false
	}
	if len(e.conscriptCntArray) == 0 {
		return false
	}
	e.conscriptCntArray = nil
	e._dt.markFullReplace(FieldArmy_conscriptCntArray)
	return true
}

func (e *ArmyEntity) LenGens() int {
	if e == nil {
		return 0
	}
	return len(e.gens)
}

func (e *ArmyEntity) AtGens(index int) (GeneralState, bool) {
	var z GeneralState
	if e == nil {
		return z, false
	}
	if index < 0 || index >= len(e.gens) {
		return z, false
	}
	v := e.gens[index]
	if v == nil {
		return z, true
	}
	return v.Save(), true
}

func (e *ArmyEntity) ForEachGens(fn func(index int, value GeneralState)) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.gens {
		var state GeneralState
		if v != nil {
			state = v.Save()
		}
		fn(i, state)
	}
}

func (e *ArmyEntity) RangeGens(fn func(index int, value GeneralState) bool) {
	if e == nil || fn == nil {
		return
	}
	for i, v := range e.gens {
		var state GeneralState
		if v != nil {
			state = v.Save()
		}
		if !fn(i, state) {
			return
		}
	}
}

func (e *ArmyEntity) ReplaceGens(v []GeneralState) bool {
	if e == nil {
		return false
	}
	if slicesEqual_gens(snapshotSlice_gens(e.gens), v) {
		return false
	}
	e.gens = hydrateSlice_gens(v)
	e._dt.markFullReplace(FieldArmy_gens)
	return true
}

func (e *ArmyEntity) AppendGens(values ...GeneralState) bool {
	if e == nil || len(values) == 0 {
		return false
	}
	for _, v := range values {
		rv := HydrateGeneralEntity(v)
		e.gens = append(e.gens, rv)
		e._dt.markSliceAppend(FieldArmy_gens, v)
	}
	return true
}

func (e *ArmyEntity) SetGensAt(index int, value GeneralState) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.gens) {
		return false
	}
	var oldState GeneralState
	if e.gens[index] != nil {
		oldState = e.gens[index].Save()
	}
	if reflect.DeepEqual(oldState, value) {
		return false
	}
	e.gens[index] = HydrateGeneralEntity(value)
	e._dt.markSliceSet(FieldArmy_gens, index, value)
	return true
}

func (e *ArmyEntity) UpdateGensAt(index int, fn func(value *GeneralEntity)) bool {
	if e == nil || fn == nil {
		return false
	}
	if index < 0 || index >= len(e.gens) {
		return false
	}
	v := e.gens[index]
	if v == nil {
		return false
	}
	before := v.Save()
	fn(v)
	after := v.Save()
	if reflect.DeepEqual(before, after) {
		return false
	}
	e._dt.markSliceSet(FieldArmy_gens, index, after)
	return true
}

func (e *ArmyEntity) RemoveGensAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.gens) {
		return false
	}
	e.gens = append(e.gens[:index], e.gens[index+1:]...)
	e._dt.markSliceRemoveAt(FieldArmy_gens, index)
	return true
}

func (e *ArmyEntity) SwapRemoveGensAt(index int) bool {
	if e == nil {
		return false
	}
	if index < 0 || index >= len(e.gens) {
		return false
	}
	last := len(e.gens) - 1
	if index != last {
		e.gens[index] = e.gens[last]
	}
	e.gens = e.gens[:last]
	e._dt.markSliceSwapRemoveAt(FieldArmy_gens, index)
	return true
}

func (e *ArmyEntity) ClearGens() bool {
	if e == nil {
		return false
	}
	if len(e.gens) == 0 {
		return false
	}
	e.gens = nil
	e._dt.markFullReplace(FieldArmy_gens)
	return true
}

func (e *ArmyEntity) CellX() int {
	if e == nil {
		var z int
		return z
	}
	return e.cellX
}

func (e *ArmyEntity) SetCellX(v int) bool {
	if e == nil {
		return false
	}
	if e.cellX == v {
		return false
	}
	e.cellX = v
	e._dt.mark(FieldArmy_cellX)
	return true
}

func (e *ArmyEntity) CellY() int {
	if e == nil {
		var z int
		return z
	}
	return e.cellY
}

func (e *ArmyEntity) SetCellY(v int) bool {
	if e == nil {
		return false
	}
	if e.cellY == v {
		return false
	}
	e.cellY = v
	e._dt.mark(FieldArmy_cellY)
	return true
}
