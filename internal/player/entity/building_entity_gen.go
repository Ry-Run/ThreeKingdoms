// Code generated by gen_entities; DO NOT EDIT.
package entity

import (
	"sort"
	"time"
)

const (
	FieldBuilding_id           Field = "id"
	FieldBuilding_buildingType Field = "buildingType"
	FieldBuilding_level        Field = "level"
	FieldBuilding_oPLevel      Field = "oPLevel"
	FieldBuilding_x            Field = "x"
	FieldBuilding_y            Field = "y"
	FieldBuilding_name         Field = "name"
	FieldBuilding_wood         Field = "wood"
	FieldBuilding_iron         Field = "iron"
	FieldBuilding_stone        Field = "stone"
	FieldBuilding_grain        Field = "grain"
	FieldBuilding_defender     Field = "defender"
	FieldBuilding_curDurable   Field = "curDurable"
	FieldBuilding_maxDurable   Field = "maxDurable"
	FieldBuilding_occupyTime   Field = "occupyTime"
	FieldBuilding_endTime      Field = "endTime"
	FieldBuilding_giveUpTime   Field = "giveUpTime"
)

type BuildingEntityCollectionChange struct {
	FullReplace       bool
	MapSet            map[string]any
	MapDeleteKeys     []string
	SliceSet          map[int]any
	SliceAppend       []any
	SliceRemoveAt     []int
	SliceSwapRemoveAt []int
}

type BuildingEntityCollectionChangeInner struct {
	fullReplace       bool
	mapSet            map[string]any
	mapDelete         map[string]struct{}
	sliceSet          map[int]any
	sliceAppend       []any
	sliceRemoveAt     []int
	sliceSwapRemoveAt []int
}

type BuildingEntityTrace struct {
	dirty   bool
	trace   map[Field]bool
	changes map[Field]*BuildingEntityCollectionChangeInner
}

func (t *BuildingEntityTrace) mark(f Field) {
	t.dirty = true
	if t.trace == nil {
		t.trace = make(map[Field]bool, 8)
	}
	t.trace[f] = true
}

func (t *BuildingEntityTrace) ensureChange(f Field) *BuildingEntityCollectionChangeInner {
	if t.changes == nil {
		t.changes = make(map[Field]*BuildingEntityCollectionChangeInner, 4)
	}
	ch, ok := t.changes[f]
	if !ok || ch == nil {
		ch = &BuildingEntityCollectionChangeInner{}
		t.changes[f] = ch
	}
	return ch
}

func (t *BuildingEntityTrace) markFullReplace(f Field) {
	t.mark(f)
	ch := t.ensureChange(f)
	ch.fullReplace = true
	ch.mapSet = nil
	ch.mapDelete = nil
	ch.sliceSet = nil
	ch.sliceAppend = nil
	ch.sliceRemoveAt = nil
	ch.sliceSwapRemoveAt = nil
}

func (t *BuildingEntityTrace) markMapSet(f Field, key string, value any) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.mapSet == nil {
		ch.mapSet = make(map[string]any, 4)
	}
	ch.mapSet[key] = value
	if ch.mapDelete != nil {
		delete(ch.mapDelete, key)
	}
}

func (t *BuildingEntityTrace) markMapDelete(f Field, key string) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.mapDelete == nil {
		ch.mapDelete = make(map[string]struct{}, 4)
	}
	ch.mapDelete[key] = struct{}{}
	if ch.mapSet != nil {
		delete(ch.mapSet, key)
	}
}

func (t *BuildingEntityTrace) markSliceAppend(f Field, values ...any) {
	if len(values) == 0 {
		return
	}
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceAppend = append(ch.sliceAppend, values...)
}

func (t *BuildingEntityTrace) markSliceSet(f Field, index int, value any) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	if ch.sliceSet == nil {
		ch.sliceSet = make(map[int]any, 4)
	}
	ch.sliceSet[index] = value
}

func (t *BuildingEntityTrace) markSliceRemoveAt(f Field, index int) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceRemoveAt = append(ch.sliceRemoveAt, index)
}

func (t *BuildingEntityTrace) markSliceSwapRemoveAt(f Field, index int) {
	t.mark(f)
	ch := t.ensureChange(f)
	if ch.fullReplace {
		return
	}
	ch.sliceSwapRemoveAt = append(ch.sliceSwapRemoveAt, index)
}

type BuildingState struct {
	Id           int
	BuildingType int8
	Level        int8
	OPLevel      int8
	X            int
	Y            int
	Name         string
	Wood         int
	Iron         int
	Stone        int
	Grain        int
	Defender     int
	CurDurable   int
	MaxDurable   int
	OccupyTime   time.Time
	EndTime      time.Time
	GiveUpTime   int64
}

type BuildingEntitySnap struct {
	Version     uint64
	State       BuildingState
	DirtyFields []Field
	Changes     map[Field]BuildingEntityCollectionChange
}

type BuildingEntity struct {
	id           int
	buildingType int8
	level        int8
	oPLevel      int8
	x            int
	y            int
	name         string
	wood         int
	iron         int
	stone        int
	grain        int
	defender     int
	curDurable   int
	maxDurable   int
	occupyTime   time.Time
	endTime      time.Time
	giveUpTime   int64
	_dt          BuildingEntityTrace
}

func HydrateBuildingEntity(s BuildingState) *BuildingEntity {
	return &BuildingEntity{
		id:           s.Id,
		buildingType: s.BuildingType,
		level:        s.Level,
		oPLevel:      s.OPLevel,
		x:            s.X,
		y:            s.Y,
		name:         s.Name,
		wood:         s.Wood,
		iron:         s.Iron,
		stone:        s.Stone,
		grain:        s.Grain,
		defender:     s.Defender,
		curDurable:   s.CurDurable,
		maxDurable:   s.MaxDurable,
		occupyTime:   s.OccupyTime,
		endTime:      s.EndTime,
		giveUpTime:   s.GiveUpTime,
	}
}

func (e *BuildingEntity) Dirty() bool {
	if e == nil {
		return false
	}
	if e._dt.dirty {
		return true
	}
	return false
}

func (e *BuildingEntity) ClearDirty() {
	if e == nil {
		return
	}
	e._dt = BuildingEntityTrace{}
}

func (e *BuildingEntity) DirtyFields() []Field {
	if e == nil {
		return nil
	}
	trace := make(map[Field]bool, len(e._dt.trace)+4)
	for k := range e._dt.trace {
		trace[k] = true
	}
	if len(trace) == 0 {
		return nil
	}
	out := make([]Field, 0, len(trace))
	for k := range trace {
		out = append(out, k)
	}
	sort.Slice(out, func(i, j int) bool { return out[i] < out[j] })
	return out
}

func (e *BuildingEntity) DirtyChanges() map[Field]BuildingEntityCollectionChange {
	if e == nil || len(e._dt.changes) == 0 {
		return nil
	}
	out := make(map[Field]BuildingEntityCollectionChange, len(e._dt.changes))
	for f, ch := range e._dt.changes {
		if ch == nil {
			continue
		}
		item := BuildingEntityCollectionChange{
			FullReplace: ch.fullReplace,
		}
		if len(ch.mapSet) > 0 {
			item.MapSet = make(map[string]any, len(ch.mapSet))
			for k, v := range ch.mapSet {
				item.MapSet[k] = v
			}
		}
		if len(ch.mapDelete) > 0 {
			keys := make([]string, 0, len(ch.mapDelete))
			for k := range ch.mapDelete {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			item.MapDeleteKeys = keys
		}
		if len(ch.sliceSet) > 0 {
			item.SliceSet = make(map[int]any, len(ch.sliceSet))
			for idx, v := range ch.sliceSet {
				item.SliceSet[idx] = v
			}
		}
		if len(ch.sliceAppend) > 0 {
			item.SliceAppend = append([]any(nil), ch.sliceAppend...)
		}
		if len(ch.sliceRemoveAt) > 0 {
			item.SliceRemoveAt = append([]int(nil), ch.sliceRemoveAt...)
		}
		if len(ch.sliceSwapRemoveAt) > 0 {
			item.SliceSwapRemoveAt = append([]int(nil), ch.sliceSwapRemoveAt...)
		}
		out[f] = item
	}
	return out
}

func cloneBuildingEntityCollectionChange(in BuildingEntityCollectionChange) BuildingEntityCollectionChange {
	out := in
	if in.MapSet != nil {
		out.MapSet = make(map[string]any, len(in.MapSet))
		for k, v := range in.MapSet {
			out.MapSet[k] = v
		}
	}
	if in.MapDeleteKeys != nil {
		out.MapDeleteKeys = append([]string(nil), in.MapDeleteKeys...)
	}
	if in.SliceSet != nil {
		out.SliceSet = make(map[int]any, len(in.SliceSet))
		for idx, v := range in.SliceSet {
			out.SliceSet[idx] = v
		}
	}
	if in.SliceAppend != nil {
		out.SliceAppend = append([]any(nil), in.SliceAppend...)
	}
	if in.SliceRemoveAt != nil {
		out.SliceRemoveAt = append([]int(nil), in.SliceRemoveAt...)
	}
	if in.SliceSwapRemoveAt != nil {
		out.SliceSwapRemoveAt = append([]int(nil), in.SliceSwapRemoveAt...)
	}
	return out
}

func (e *BuildingEntity) Save() BuildingState {
	var s BuildingState
	if e == nil {
		return s
	}
	s.Id = e.id
	s.BuildingType = e.buildingType
	s.Level = e.level
	s.OPLevel = e.oPLevel
	s.X = e.x
	s.Y = e.y
	s.Name = e.name
	s.Wood = e.wood
	s.Iron = e.iron
	s.Stone = e.stone
	s.Grain = e.grain
	s.Defender = e.defender
	s.CurDurable = e.curDurable
	s.MaxDurable = e.maxDurable
	s.OccupyTime = e.occupyTime
	s.EndTime = e.endTime
	s.GiveUpTime = e.giveUpTime
	return s
}

func NewBuildingEntitySnap(version uint64, e *BuildingEntity) *BuildingEntitySnap {
	if e == nil {
		return nil
	}
	dirtyFields := e.DirtyFields()
	changes := e.DirtyChanges()
	return &BuildingEntitySnap{
		Version:     version,
		State:       e.Save(),
		DirtyFields: dirtyFields,
		Changes:     changes,
	}
}

func (s *BuildingEntitySnap) Clone() *BuildingEntitySnap {
	if s == nil {
		return nil
	}
	out := &BuildingEntitySnap{Version: s.Version}
	out.State = s.State
	out.DirtyFields = append([]Field(nil), s.DirtyFields...)
	if len(s.Changes) > 0 {
		out.Changes = make(map[Field]BuildingEntityCollectionChange, len(s.Changes))
		for f, ch := range s.Changes {
			out.Changes[f] = cloneBuildingEntityCollectionChange(ch)
		}
	}
	return out
}

func (e *BuildingEntity) Id() int {
	if e == nil {
		var z int
		return z
	}
	return e.id
}

func (e *BuildingEntity) SetId(v int) bool {
	if e == nil {
		return false
	}
	if e.id == v {
		return false
	}
	e.id = v
	e._dt.mark(FieldBuilding_id)
	return true
}

func (e *BuildingEntity) BuildingType() int8 {
	if e == nil {
		var z int8
		return z
	}
	return e.buildingType
}

func (e *BuildingEntity) SetBuildingType(v int8) bool {
	if e == nil {
		return false
	}
	if e.buildingType == v {
		return false
	}
	e.buildingType = v
	e._dt.mark(FieldBuilding_buildingType)
	return true
}

func (e *BuildingEntity) Level() int8 {
	if e == nil {
		var z int8
		return z
	}
	return e.level
}

func (e *BuildingEntity) SetLevel(v int8) bool {
	if e == nil {
		return false
	}
	if e.level == v {
		return false
	}
	e.level = v
	e._dt.mark(FieldBuilding_level)
	return true
}

func (e *BuildingEntity) OPLevel() int8 {
	if e == nil {
		var z int8
		return z
	}
	return e.oPLevel
}

func (e *BuildingEntity) SetOPLevel(v int8) bool {
	if e == nil {
		return false
	}
	if e.oPLevel == v {
		return false
	}
	e.oPLevel = v
	e._dt.mark(FieldBuilding_oPLevel)
	return true
}

func (e *BuildingEntity) X() int {
	if e == nil {
		var z int
		return z
	}
	return e.x
}

func (e *BuildingEntity) SetX(v int) bool {
	if e == nil {
		return false
	}
	if e.x == v {
		return false
	}
	e.x = v
	e._dt.mark(FieldBuilding_x)
	return true
}

func (e *BuildingEntity) Y() int {
	if e == nil {
		var z int
		return z
	}
	return e.y
}

func (e *BuildingEntity) SetY(v int) bool {
	if e == nil {
		return false
	}
	if e.y == v {
		return false
	}
	e.y = v
	e._dt.mark(FieldBuilding_y)
	return true
}

func (e *BuildingEntity) Name() string {
	if e == nil {
		var z string
		return z
	}
	return e.name
}

func (e *BuildingEntity) SetName(v string) bool {
	if e == nil {
		return false
	}
	if e.name == v {
		return false
	}
	e.name = v
	e._dt.mark(FieldBuilding_name)
	return true
}

func (e *BuildingEntity) Wood() int {
	if e == nil {
		var z int
		return z
	}
	return e.wood
}

func (e *BuildingEntity) SetWood(v int) bool {
	if e == nil {
		return false
	}
	if e.wood == v {
		return false
	}
	e.wood = v
	e._dt.mark(FieldBuilding_wood)
	return true
}

func (e *BuildingEntity) Iron() int {
	if e == nil {
		var z int
		return z
	}
	return e.iron
}

func (e *BuildingEntity) SetIron(v int) bool {
	if e == nil {
		return false
	}
	if e.iron == v {
		return false
	}
	e.iron = v
	e._dt.mark(FieldBuilding_iron)
	return true
}

func (e *BuildingEntity) Stone() int {
	if e == nil {
		var z int
		return z
	}
	return e.stone
}

func (e *BuildingEntity) SetStone(v int) bool {
	if e == nil {
		return false
	}
	if e.stone == v {
		return false
	}
	e.stone = v
	e._dt.mark(FieldBuilding_stone)
	return true
}

func (e *BuildingEntity) Grain() int {
	if e == nil {
		var z int
		return z
	}
	return e.grain
}

func (e *BuildingEntity) SetGrain(v int) bool {
	if e == nil {
		return false
	}
	if e.grain == v {
		return false
	}
	e.grain = v
	e._dt.mark(FieldBuilding_grain)
	return true
}

func (e *BuildingEntity) Defender() int {
	if e == nil {
		var z int
		return z
	}
	return e.defender
}

func (e *BuildingEntity) SetDefender(v int) bool {
	if e == nil {
		return false
	}
	if e.defender == v {
		return false
	}
	e.defender = v
	e._dt.mark(FieldBuilding_defender)
	return true
}

func (e *BuildingEntity) CurDurable() int {
	if e == nil {
		var z int
		return z
	}
	return e.curDurable
}

func (e *BuildingEntity) SetCurDurable(v int) bool {
	if e == nil {
		return false
	}
	if e.curDurable == v {
		return false
	}
	e.curDurable = v
	e._dt.mark(FieldBuilding_curDurable)
	return true
}

func (e *BuildingEntity) MaxDurable() int {
	if e == nil {
		var z int
		return z
	}
	return e.maxDurable
}

func (e *BuildingEntity) SetMaxDurable(v int) bool {
	if e == nil {
		return false
	}
	if e.maxDurable == v {
		return false
	}
	e.maxDurable = v
	e._dt.mark(FieldBuilding_maxDurable)
	return true
}

func (e *BuildingEntity) OccupyTime() time.Time {
	if e == nil {
		var z time.Time
		return z
	}
	return e.occupyTime
}

func (e *BuildingEntity) SetOccupyTime(v time.Time) bool {
	if e == nil {
		return false
	}
	if e.occupyTime.Equal(v) {
		return false
	}
	e.occupyTime = v
	e._dt.mark(FieldBuilding_occupyTime)
	return true
}

func (e *BuildingEntity) EndTime() time.Time {
	if e == nil {
		var z time.Time
		return z
	}
	return e.endTime
}

func (e *BuildingEntity) SetEndTime(v time.Time) bool {
	if e == nil {
		return false
	}
	if e.endTime.Equal(v) {
		return false
	}
	e.endTime = v
	e._dt.mark(FieldBuilding_endTime)
	return true
}

func (e *BuildingEntity) GiveUpTime() int64 {
	if e == nil {
		var z int64
		return z
	}
	return e.giveUpTime
}

func (e *BuildingEntity) SetGiveUpTime(v int64) bool {
	if e == nil {
		return false
	}
	if e.giveUpTime == v {
		return false
	}
	e.giveUpTime = v
	e._dt.mark(FieldBuilding_giveUpTime)
	return true
}
